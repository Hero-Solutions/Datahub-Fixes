# Catmandu Fix
#
# Institution: Museum voor Schone Kunsten Gent
# Description: Converts Adlib Structured XML exposed via ErfgoedInzicht OAI to LIDO 1.0
# Created: 15/9/2017



### Prepare an intermediate structure

# Copy relevant Adlib fields in order to create a dedicated lido structure

    copy_field(_metadata.object_number, or_record.object_number)
    copy_field(_metadata.object_category, or_record.object_category)
    copy_field('_metadata.object_category\.lref', or_record.object_category_id)
    copy_field(_metadata.Object_name, or_record.object_name)
    copy_field(_metadata.Titel_translation, or_record.title_translation)
    copy_field(_metadata.Title, or_record.title)
    copy_field('_metadata.institution\.name', or_record.institution)
    copy_field(_metadata.Description, or_record.description)
    copy_field(_metadata.Dimension, or_record.dimensions)
    copy_field(_metadata.Production, or_record.production)
    copy_field(_metadata.Production_date, or_record.production_date)
    copy_field('_metadata.production\.period\.lref', or_record.production_period_id)
    copy_field('_metadata.production\.period', or_record.production_period)
    copy_field(_metadata.Material, or_record.materials)
    copy_field(_metadata.physical_description, or_record.physical_description)
    copy_field('_metadata.content\.motif\.general', or_record.subject)
    copy_field(_metadata.priref, or_record.priref)

# Remove all Adlib fields, retaining only the fields to create the lido structure

    retain(or_record)



### Mapping to lido structure

# Mapping Facets
# -----------------------------------------------------------------------------------------------
# Adlib                           LIDO                              VKC
#                                    lido:lidoRecID               
#                                    lido:objectPublishedID    
#                                    lido:category
#                                    lido:objectWorkType
#   object_category.lref                lido:conceptID
#                                       lido:term                        
#                                           pref: alternate
#   object_category                         pref: preferred              Type Kunstwerk
#                                    lido:classification
#                                       pref: alternate
#   Object_name.object_name             pref: preferred
#                                    lido:titleSet
#   Titel_translation                   pref: alternate
#   Title                               pref: preferred              
#   institution.name                 lido:repositoryName                 Museum
#   Description                      lido:objectDescriptionSet           Info over beeldgebruik
#   Dimension                        lido:displayObjectMeasurements      Afmetingen 
#                                    lido:eventType
#   Production.creator.value         lido:eventActor
#                                       pref: alternate
#                                       pref: preferred                  Kunstenaar
#   Production_date                  lido:displayDate                    Datering
#   Production_date                  lido:date
#                                    lido:periodName              
#   production.period.lref              lido:conceptID
#   production.period                   lido:term                        Periode
#                                    lido:termMaterialsTech
#                                       pref: alternate
#   Material                            pref: preferred
#   physical_description             lido:displayMaterialsTech           Materiaal
#   Production.production.place      lido:namePlaceSet
#   content.motif.general            lido:subjectConcept                 Voorstelling
#                                    lido:recordID
#   object_number                       type: local                      Inventarisnummer
#   priref                              type: Adlib
#                                    lido:recordType
#   institution.name                 lido:recordSource                   Museum



### LIDO lidoRecID

    copy_field(or_record.object_number, or_record.identificator)

    lookup_in_store(or_record.identificator, DBI, data_source: 'dbi:SQLite:/tmp/import.PIDS_ALL_UTF8.sqlite')

    if all_match(or_record.identificator.dataPid, '.*\S.*')
    
        # ID
        #
        # The ID in Solr is based on the data_pid. The data_pid is converted to a string
        # which can be safely used as an identifier in Project Blacklight. The format of
        # the ID field looks like this:
        #
        #   oai:datahub.vlaamsekunstcollectie.be:<domain>:<identifier>
        #   ex. oai:datahub.vlaamsekunstcollectie.be:kmksa:254
        #   ex. oai:datahub.vlaamsekunstcollectie.be:collectievlaamsegemeenschap:837
        #
        # Note: the .tld is stripped from the domainname because the . (dot) breaks the
        # route matching algoritm.

        copy_field('or_record.identificator.dataPid', 'or_record.identificator.oaiPid')
        parse_text('or_record.identificator.oaiPid', '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
        join_field('or_record.identificator.oaiPid', ':')
        prepend('or_record.identificator.oaiPid', 'oai:datahub.vlaamsekunstcollectie.be:')

        lido_baseid(
            lidoRecID,
            or_record.identificator.oaiPid,
            -type: urn,
            -source: 'Vlaamse Kunstcollectie - Arthub Flanders',
            -label: dataPID,
            -pref: preferred
        )

        lido_baseid(
            lidoRecID,
            or_record.identificator.dataPid,
            -type: purl,
            -source: 'Musea Brugge - Groeningemuseum',
            -label: dataPID,
            -pref: alternate
        )
    
    end


### LIDO objectPublishedID

    if all_match(or_record.identificator.workPid, '.*\S.*')

        lido_baseid(
            objectPublishedID,
            or_record.identificator.workPid,
            -type: purl,
            -source: 'Museum voor Schone Kunsten Gent',
            -label: workPID
        )

    end


### LIDO category

    add_field(or_record.CIDOCCategoryTerm, 'Man-Made Object')
    add_field(or_record.CIDOCCategoryURI, 'http://www.cidoc-crm.org/crm-concepts/E22')

    lido_term(
        category,
        or_record.CIDOCCategoryTerm,
        -conceptid: or_record.CIDOCCategoryURI,
        -type: purl,
        -source: cidoc-crm
    )



### LIDO descriptiveMetadata

## LIDO objectClassificationWrap

# LIDO objectWorkType

    # If it is a string, convert to an array with a single value first.

    unless is_array(or_record.object_category) 
        move_field(or_record.object_category, or_record.tmp)
        set_array(or_record.object_category)
        move_field(or_record.tmp, or_record.object_category.$last)
    end

    # We'll have multiple classifications: the corresponding value in AAT (type:alternate) and the value from the Adlib field object_name itself (type:preferred)

    do list(path: or_record.object_category, var: c)

        # Value in Adlib

        if all_match(c.value, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$append,
                c.value,
                -conceptid: or_record.object_category_id,
                -type: local,
                -source: Adlib,
                -pref: preferred,
                -lang: nl
            )

        end
    
        # Corresponding value in AAT

        copy_field(c.value, c.aat)

        lookup_in_store(c.aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        if all_match(c.aat._id, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                c.aat.aatterm,
                -conceptid: c.aat.aaturi,
                -type: purl,
                -source: AAT,
                -pref: alternate,
                -lang: nl
            )

        end

    end

# LIDO classification

    unless is_array(or_record.object_name) 
        move_field(or_record.object_name, or_record.tmp)
        set_array(or_record.object_name)
        move_field(or_record.tmp, or_record.object_name.$last)
    end

    # We'll have multiple classifications: the corresponding value in AAT (type:alternate) and the value from the Adlib field object_name itself (type:preferred)

    do list(path: or_record.object_name, var: c)

        # Value in Adlib

        if all_match(c.object_name.value, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$append,
                c.object_name.value,
                -conceptid: 'c.object_name\.lref',
                -type: local,
                -source: Adlib,
                -pref: preferred,
                -lang: nl
            )

        end
    
        # Corresponding value in AAT

        copy_field(c.object_name.value, c.aat)

        lookup_in_store(c.aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        if all_match(c.aat._id, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last,
                c.aat.aatterm,
                -conceptid: c.aat.aaturi,
                -type: purl,
                -source: AAT,
                -pref: alternate,
                -lang: nl
            )

        end

    end


## LIDO objectIdentificationWrap

# LIDO titleSet

    if all_match('or_record.title_translation.1.title\.translation', '.*\S.*')
        
        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.$append,
            'or_record.title_translation.1.title\.translation',
            -value_pref: alternate,
            -value_lang: en
        )

        unless is_array(or_record.title) 
            move_field(or_record.title, or_record.tmp)
            set_array(or_record.title)
            move_field(or_record.tmp, or_record.title.$last)
        end

        if all_match(or_record.title.0.title.value, '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.$last,
                or_record.title.0.title.value,
                -value_pref: preferred,
                -value_lang: nl
            )

        end

    else

        unless is_array(or_record.title) 
            move_field(or_record.title, or_record.tmp)
            set_array(or_record.title)
            move_field(or_record.tmp, or_record.title.$last)
        end

        if all_match(or_record.title.0.title.value, '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.$last,
                or_record.title.0.title.value,
                -value_lang: nl
            )

        end

    end

# LIDO repositoryName

    if all_match(or_record.institution.value, '.*\S.*')

        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.repositoryName.legalBodyName,
            or_record.institution.value
        )

    end


# LIDO objectDescriptionSet

    # If the Adlib field Description is an array, map the first description (index 0) to a LIDO field lido:objectDescriptionSet with parameter lido:lang="nl" and the third description (index 2) to a LIDO field lido:objectDescriptionSet with parameter lido:lang="en"

    if is_array(or_record.description)

        if all_match(or_record.description.0.description, '.*\S.*')

            lido_descriptivenote(
                descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet,
                or_record.description.0.description,
                -pref: preferred,
                -lang: nl
            )

        end

        if all_match(or_record.description.2.description, '.*\S.*')

            lido_descriptivenote(
                descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet,
                or_record.description.2.description,
                -pref: alternate,
                -lang: en
            )

        end

    # If the Adlib field Description is no array

    else

        if all_match(or_record.description.description,  '.*\S.*')

            lido_descriptivenote(
                descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet,
                or_record.description.description,
                -lang: nl
            )

        end

    end

# LIDO displayObjectMeasurements

    do list(path:or_record.dimensions, var:c)
  
        if all_equal('c.dimension\.part', geheel)

            copy_field('c.dimension\.type.value', c.dimension_type)
            copy_field('c.dimension\.unit.value', c.dimension_unit)
            copy_field('c.dimension\.value', c.dimension_value)

            unless all_match(c.dimension_unit, '.*\S.*')
                set_field(c.dimension_unit, n/a)
            end

            unless all_match(c.dimension_value, '.*\S.*')
                set_field(c.dimension_value, n/a)
            end

            unless is_null(c.dimension_type)

                lido_objectmeasurements(
                    '',
                    c.dimension_type,
                    c.dimension_unit,
                    c.dimension_value
                )

            end

        end

    end


## LIDO eventWrap

# LIDO eventType

    add_field(or_record.event_type, production)
    
    lido_term(
        descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
        or_record.event_type
    )

# Lido eventActor

    unless is_array(or_record.production) 
        move_field(or_record.production, or_record.tmp)
        set_array(or_record.production)
        move_field(or_record.tmp, or_record.production.$last)
    end

    do list (path: or_record.production, var: c)

        unless all_match('c.creator\.qualifier', '.*\S.*')
            set_field('c.creator\.qualifier', 'n/a')
        end

        unless all_match('c.creator\.role.value', '.*\S.*')
            set_field('c.creator\.role.value', 'n/a')
        end

        unless all_match('c.creator\.date_of_birth', '.*\S.*')
            set_field('c.creator\.date_of_birth', 'n/a')
        end

        unless all_match('c.creator\.date_of_death', '.*\S.*')
            set_field('c.creator\.date_of_death', 'n/a')
        end

        if all_match(c.creator.value, '.*\S.*')

            lido_actor(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append,
                'c.creator\.lref',
                c.creator.value,
                -id_source: Adlib,
                -id_type: local,
                -birthdate: 'c.creator\.date_of_birth',
                -deathdate: 'c.creator\.date_of_death',
                -role: 'c.creator\.role.value',
                -qualifier: 'c.creator\.qualifier',
                -name_pref: preferred
            )

        end

        # Role. Work around. -role switch in lido_actor does not work correctly.

        lido_term(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.roleActor,
            'c.creator\.role.value',
        )

        # Add Persistent URI data to actor

        copy_field(c.creator.value, c.creator.pid)

        lookup_in_store(c.creator.pid, DBI, data_source: "dbi:SQLite:/tmp/import.CREATORS_UTF8.sqlite")

        # Preferred label from Flemish Art Collection concordance database

        if all_match(c.creator.pid._id, '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.nameActorSet.$last,
                c.creator.pid._id,
                -value_pref: alternate
            )

        end

        # Creator Persistent URI's

        if all_match(c.creator.pid.viaf_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.viaf_uri,
                -source: VIAF,
                -type: purl
            )

        end

        if all_match(c.creator.pid.rkd_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.$last.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.rkd_uri,
                -source: RKD,
                -type: purl
            )

        end

        if all_match(c.creator.pid.wikidata_uri, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.$last.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.wikidata_uri,
                -source: Wikidata,
                -type: purl
            )

        end

    end

# LIDO displayDate

    if all_match('or_record.production_date.production\.date\.start', '.*\S.*')

        if all_match('or_record.production_date.production\.date\.end', '.*\S.*')

            paste(or_record.displayDate, 'or_record.production_date.production\.date\.start', 'or_record.production_date.production\.date\.end', join_char:' - ')

        else

            copy_field('or_record.production_date.production\.date\.start', or_record.displayDate)

        end

        if all_match('or_record.production_date.production\.date\.start\.prec', circa)
            paste(or_record.displayDate, 'or_record.production_date.production\.date\.start\.prec', or_record.displayDate)
        end

        lido_basevalue(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.displayDate,
            or_record.displayDate
        )

    end

# LIDO date

    unless all_match('or_record.production_date.production\.date\.start\.prec', '.*\S.*')
        set_field('or_record.production_date.production\.date\.start\.prec', n/a)
    end

    unless all_match('or_record.production_date.production\.date\.end\.prec', '.*\S.*')
        set_field('or_record.production_date.production\.date\.end\.prec', n/a)
    end

    if all_match('or_record.production_date.production\.date\.start', '.*\S.*')

        if all_match('or_record.production_date.production\.date\.end', '.*\S.*')

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -earliest_date: 'or_record.production_date.production\.date\.start',
                -earliest_date_type: 'or_record.production_date.production\.date\.start\.prec',
                -latest_date: 'or_record.production_date.production\.date\.end',
                -latest_date_type: 'or_record.production_date.production\.date\.end\.prec'
            )

        else

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -earliest_date: 'or_record.production_date.production\.date\.start',
                -earliest_date_type: 'or_record.production_date.production\.date\.start\.prec'
            )

        end

    end

# LIDO periodName

    if all_match(or_record.production_period.value, '.*\S.*')

        lido_term(
            descriptiveMetadata.eventWrap.eventSet.$last.event.periodName,
            or_record.production_period.value,
            -conceptid: or_record.production_period_id,
            -lang: nl,
            -source: Adlib,
            -type: local
        )

    end

# LIDO termMaterialsTech

    unless is_array(or_record.materials) 
        move_field(or_record.materials, or_record.tmp)
        set_array(or_record.materials)
        move_field(or_record.tmp, or_record.materials.$last)
    end

    # We'll have multiple classifications: the corresponding value in AAT (type:alternate) and the value from the Adlib field object_name itself (type:preferred)

    do list(path: or_record.materials, var: c)

        if all_match(c.material.value, '.*\S.*')

        # Value in Adlib

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append,
                c.material.value,
                -conceptid: 'c.material\.lref',
                -type: local,
                -source: Adlib,
                -pref: preferred,
                -lang: nl
            )

        end

        # Corresponding value in AAT

        copy_field(c.material.value, c.aat)

        lookup_in_store(c.aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        if all_match(c.aat._id, '.*\S.*')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$last,
                c.aat.aatterm,
                -conceptid: c.aat.aaturi,
                -type: purl,
                -source: AAT,
                -pref: alternate,
                -lang: nl
            )

        end

    end

# LIDO displayMaterialsTech
    
    if all_match(or_record.physical_description, '.*\S.*')

        lido_basevalue(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.displayMaterialsTech,
            or_record.physical_description
        )

    end

# LIDO namePlaceSet

    if all_match('or_record.production.production\.place', '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventPlace.place.namePlaceSet,
                'or_record.production.production\.place',
                -value_pref: preferred,
                -value_lang: nl
            )

    end


## LIDO objectRelationWrap

# LIDO subjectConcept

    unless is_array(or_record.subject) 
        move_field(or_record.subject, or_record.tmp)
        set_array(or_record.subject)
        move_field(or_record.tmp, or_record.subject.$last)
    end

    do list(path: or_record.subject, var: c)

        if all_match(c.value, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.subject.subjectConcept,
                c.value,
                -lang: nl
            )

        end

    end

### LIDO administrativeMetadata

# LIDO recordID

    if all_match(or_record.object_number, '.*\S.*')

        lido_baseid(
            administrativeMetadata.recordWrap.recordID,
            or_record.object_number,
            -type: local
        )

    end

    unless is_array(or_record.priref) 
        move_field(or_record.priref, or_record.tmp)
        set_array(or_record.priref)
        move_field(or_record.tmp, or_record.priref.$last)
    end

    if all_match(or_record.priref.0,'.*\S.*')

        lido_baseid(
            administrativeMetadata.recordWrap.recordID,
            or_record.priref.0,
            -type: local,
            -source: Adlib
        )

    end

# LIDO recordType

    add_field('or_record.AATRecordTypeTerm', 'Item')
    add_field('or_record.AATRecordTypeID', 'http://vocab.getty.edu/aat/300133025')

    lido_term(
        administrativeMetadata.recordWrap.recordType,
        or_record.AATRecordTypeTerm,
        -conceptid: or_record.AATRecordTypeID,
        -type: local,
        -source: AAT
    )

# LIDO recordSource

    if all_match(or_record.institution.value, '.*\S.*')

        lido_basenameset(
            administrativeMetadata.recordWrap.recordSource.legalBodyName,
            or_record.institution.value
        )

    end

    add_field('or_record.LegalBodyWebLink', 'http://mskgent.be')

    lido_basevalue(
        administrativeMetadata.recordWrap.recordSource.legalBodyWeblink,
        or_record.LegalBodyWebLink
    )



### Add lang attributes to descriptiveMetadata and administrativeMetadata
add_field(descriptiveMetadata.lang, nl)
add_field(administrativeMetadata.lang, nl)

### Remove the 'or_record' structure

remove_field(or_record)