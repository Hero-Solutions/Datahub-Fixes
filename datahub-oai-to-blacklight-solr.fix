# Catmandu Fix script to convert LIDO XML data into JSON data for Solr
# (MSK data version)
#
# USAGE
# Convert to JSON
# catmandu convert OAI --url "http://datahub_ubuntu:8000/oai/" --metadataPrefx oai_lido --handler lido to JSON --pretty 1 --fix oai.fix > out-fix.json && cat out-fix.json
#
# Import into Solr
# catmandu import OAI --url "http://datahub_ubuntu:8000/oai/" --metadataPrefx oai_lido --handler lido --fix oai.fix to pbsolr

# Title - use NL
do list(path:_metadata.descriptiveMetadata.0.objectIdentificationWrap.titleWrap.titleSet.0.appellationValue, var:el)
    if all_match('el.lang', 'nl')
    copy_field('el._', "title_display")
    end
end

# Artist - use preferred

# Set the creator_role array

set_array(creator_role)
set_array(tmp_creators)

do list(path:'_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventActor', var: c)
    set_array(tmp_creator_display)

    # The name of the creator

    do list(path:c.actorInRole.actor.nameActorSet.0.appellationValue, var:creator)
        if all_match('creator.pref', 'alternate')
            copy_field(creator._, tmp_creator_display.$append)
            copy_field(creator._, tmp_creators.$append)
        end
    end

    # The qualifier of the creator (Attributed to, Workshop of,...)

    unless all_match('c.actorInRole.attributionQualifierActor.$last._', 'n/a')
        copy_field(c.actorInRole.attributionQualifierActor.$last._, tmp_creator_display.$prepend)
    end

    copy_field(c.actorInRole.roleActor, tmp_creator_display.$append)

    join_field(tmp_creator_display, " ")
    move_field(tmp_creator_display, creator_display.$append)


    # The role of the creator (if any, if roleActor is an empty node, add 'n/a' as default)

    unless all_match('c.actorInRole.roleActor.$last.term.$last._', '.*\S.*')
        add_field(creator_role.$append, 'n/a')
    end

    copy_field(c.actorInRole.roleActor.$last.term.$last._, creator_role.$append)
end

set_array(creator)
do list(path: 'tmp_creators', var: c)
    lookup_in_store(c, DBI, data_source: "dbi:SQLite:/tmp/import.CREATORS_UTF8.sqlite")
    copy_field(c.viaf_alternate, creator.$append)
end

remove_field(tmp_creators)

# ? Production date
copy_field('_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventDate.date.earliestDate._', 'production_date')

# Period - use NL field
do list(path:_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.periodName, var:per)
    if all_match('per.term.*.lang', 'nl')
        copy_field('per.term.*._', "period")
    end
end

# Repository
copy_field('_metadata.administrativeMetadata.0.recordWrap.recordSource.0.legalBodyName.0.appellationValue.0._', 'repository')

# Material
do list(path: '_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventMaterialsTech', var: mat)
    do list(path: 'mat.materialsTech.termMaterialsTech.0.term', var: prefMaterial)
        if all_match('prefMaterial.pref', 'preferred')
            copy_field(prefMaterial._, material.$append)
        end
    end
end


# Dimensions
do list(path:_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet, var:el2)
    do list(path:el2.objectMeasurements.measurementsSet, var:el)
        if all_match('el.measurementType.0._', 'hoogte')
            copy_field(el.measurementValue._, dimensionsh.$append)
            copy_field(el.measurementUnit.0._, dimensionsh.$append)
            join_field(dimensionsh, ' ')
        end
        if all_match('el.measurementType.0._', 'breedte')
            copy_field(el.measurementValue._, dimensionsw.$append)
            copy_field(el.measurementUnit.0._, dimensionsw.$append)
            join_field(dimensionsw, ' ')
        end
    end
end
copy_field(dimensionsh, dimensions.$append)
remove_field(dimensionsh)
copy_field(dimensionsw, dimensions.$append)
remove_field(dimensionsw)
join_field(dimensions, ' x ')

# Category
do list(path: '_metadata.descriptiveMetadata.0.objectRelationWrap.subjectWrap.subjectSet.0.subject.subjectConcept.0.term', var: cat)
    copy_field(cat._, artwork_category.$append)
end

# Artwork_type
# Facet
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.objectWorkTypeWrap.objectWorkType', var:t)
    do list(path: 't.term', var:type)
        if all_match('type.pref', 'alternate')
            copy_field(type._, artwork_type.$append)
        end
    end
end
# Display
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.objectWorkTypeWrap.objectWorkType', var:t)
    do list(path: 't.term', var:type)
        if all_match('type.pref', 'preferred')
            copy_field(type._, artwork_type_display.$append)
        end
    end
end

# Artwork_subtype
# Facet
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.classificationWrap.classification', var:c) 
    do list(path: 'c.term', var:classification)
        if all_match('classification.pref', 'alternate')
            copy_field(classification._, artwork_subtype.$append)
        end
    end
end
# Display
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.classificationWrap.classification', var:c)
    do list(path: 'c.term', var:classification)
        if all_match('classification.pref', 'preferred')
            copy_field(classification._, artwork_subtype_display.$append)
        end
    end
end

# References
copy_field('_metadata.administrativeMetadata.0.recordWrap.recordInfoSet.0.recordInfoLink.0._', 'references')

# Object_number
copy_field('_metadata.administrativeMetadata.0.recordWrap.recordID.0._', 'object_number')
# copy_field('_metadata.administrativeMetadata.0.recordWrap.recordID.0._', 'id')

# Description
copy_field('_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.0.descriptiveNoteValue.0._', 'description')

# Work_pid
copy_field('_metadata.objectPublishedID.0._', 'work_pid')

# Data_pid
do list(path: '_metadata.lidoRecID', var:lidoRecID)
    if all_match('lidoRecID.type', 'purl')
        copy_field(lidoRecID._, data_pid)
    end
end

# ID
#
# The ID in Solr is based on the data_pid. The data_pid is converted to a string
# which can be safely used as an identifier in Project Blacklight. The format of
# the ID field looks like this:
#
#   <domain>:<identifier>
#   ex. kmksa:254
#   ex. collectievlaamsegemeenschap:837
#
# Note: the .tld is stripped from the domainname because the . (dot) breaks the
# route matching algoritm.

copy_field('data_pid', 'id')
parse_text('id', '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
replace_all('id.0', '([^.]*)\.[^.]{2,3}(?:\.[^.]{2,3})?$', '$1')
join_field(id, ':')

# remove all original fields and only retain the ones we set
remove_field('_id')
remove_field('_identifier')
remove_field('_status')
remove_field('_setSpec')
remove_field('_about')
remove_field('_datestamp')
remove_field('_metadata')