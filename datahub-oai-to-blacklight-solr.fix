# Catmandu Fix script
#
# Convert data from the VKC Datahub to the VKC Arthub.
#
# This Fix script will take LIDO XML records as an input and transform
# them into JSON objects that can be uploaded into an Apache Solr store.
#
# The Solr schema has been optimised for Project Blacklight (http://projectblacklight.org).
# The JSON objects should conform to the schema.
#
# See: https://github.com/VlaamseKunstcollectie/Arthub-Frontend/tree/master/jetty/solr
# 
# Usage:
#
#  $ catmandu convert OAI --url "http://endpoint/oai/" --metadataPrefix oai_lido 
#    --handler lido to JSON --pretty 1 --fix datahub-oai-to-blacklight-solr.fix > out.json
#
# In order to import data into the Solr core, create a pipeline and use the Datahub::Factory:
#
# see: 
#
# arthub.ini:
#
#    [Indexer]
#    plugin = Solr
#
#    [plugin_indexer_Solr]
#    file_name = '/tmp/bulk.json'
#    request_handler = 'http://datahub.box:8983/solr/blacklight-core/update/json'
#
# Usage:
#
#  $ catmandu convert OAI --url http://datahub.box/oai --handler lido 
#    to JSON --fix datahub-oai-to-blacklight-solr.fix > /tmp/bulk.json
#  $ dhconveyor index -p ../pipelines/arthub.ini -v
#

### MAPPING

# @todo document the mapping between LIDO elements and Solr fields

## Title - use NL

#  Use dutch title if exists, else use English title

do list(path:_metadata.descriptiveMetadata.0.objectIdentificationWrap.titleWrap.titleSet.0.appellationValue, var:el)
    if all_match('el.lang', 'nl')
        copy_field('el._', "title_display")
    end
end

unless all_match(title_display, '.*\S.*')
    do list(path:_metadata.descriptiveMetadata.0.objectIdentificationWrap.titleWrap.titleSet.0.appellationValue, var:el)
        copy_field('el._', "title_display")
    end
end

## Creators
 
set_array(creator)
set_array(creator_dod)
set_array(creator_dob)
set_array(creator_viaf_dod)
set_array(creator_role)
set_array(creator_display)
set_array(creator_index)

do list(path:'_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventActor', var: c)
    set_array(tmp_creator_display)
    set_array(tmp_creator_index)

    # Get the name of the creator from LIDO (preferred name)

    # Display the name as established by the museum.

    do list(path:c.actorInRole.actor.nameActorSet.0.appellationValue, var:creator)
        if all_match('creator.pref', 'preferred')
            copy_field(creator._, tmp_creator_display.$append)
            copy_field(creator._, tmp_creator_index.$append)
        end
    end

    # Add VIAF vital dates & alternate name from CREATORS_UTF8.csv

    # The original LIDO data doesn't contain those. It only contains the
    # data sanctioned by the institutions, not the actual VIAF data itself.

    copy_field(creator_display.$last, tmp_creator_concord)
    downcase(tmp_creator_concord)
    lookup_in_store(tmp_creator_concord, DBI, data_source: "dbi:SQLite:/tmp/import.CREATORS_UTF8.sqlite")

    # The VIAF vital dates are used to determine the copyright further on.
    # If the institution doesn't provide vital dates, we fall back on the
    # VIAF data.

    if all_match(tmp_creator_concord.viaf_death, '.*\S.*')
        copy_field(tmp_creator_concord.viaf_death, creator_viaf_dod.$append)
    else
       add_field(tmp_viaf_death, 'n/a')
       copy_field(tmp_viaf_death, creator_viaf_dod.$append)
       remove_field(tmp_viaf_death)
    end

    # We store the VIAF alternate name in creator search field. 
    # This allows users to search on name variants of the creator.

    if all_match(tmp_creator_concord.viaf_alternate, '.*\S.*')
        copy_field(tmp_creator_concord.viaf_alternate, creator.$append)
    else
       add_field(tmp_viaf_alternate, 'n/a')
       copy_field(tmp_viaf_alternate, creator.$append)
       remove_field(tmp_viaf_alternate)
    end

    remove_field(tmp_creator_concord)

    # Add LIDO vital dates (birth, death) of the creator

    if all_match(c.actorInRole.actor.vitalDatesActor.latestDate._, '.*\S.*')
        copy_field(c.actorInRole.actor.vitalDatesActor.latestDate._, creator_dod.$append)
    else
        add_field(tmp_creator_dod, 'n/a')
        copy_field(tmp_creator_dod, creator_dod.$append)
        remove_field(tmp_creator_dod)
    end

    if all_match(c.actorInRole.actor.vitalDatesActor.earliestDate._, '.*\S.*')
        copy_field(c.actorInRole.actor.vitalDatesActor.earliestDate._, creator_dob.$append)
    else
        add_field(tmp_creator_dob, 'n/a')
        copy_field(tmp_creator_dob, creator_dob.$append)
        remove_field(tmp_creator_dob)
    end

    # LIDO qualifier (copy after, attributed to,...)

    if all_match('c.actorInRole.attributionQualifierActor.$last._', '.*\S.*')
        unless all_match('c.actorInRole.attributionQualifierActor.$last._', 'n/a')
            
            # add the attribution to the creator_display and creator_index

            copy_field(c.actorInRole.attributionQualifierActor.$last._, tmp_creator_display.$prepend)
            copy_field(c.actorInRole.attributionQualifierActor.$last._, tmp_creator_index.$prepend)

            # We remove the vital dates from works tentatively "attributed to" an artist
            #
            # Why? Because we can't reliable establish that the work was truly created
            # by the attributed artist. i.e. The qualifier "copy after" implies
            # that this work was created by someone else.
            # 
            # We reset the vital dates here because we use them later on to establish
            # copyright. "copy after Anthony van Dyck" might have us erroneously 
            # infer that the work was created by Anthony van Dyck while it may have
            # actually been created in the 20th century.

            set_field(creator_dob.$last, 'n/a')
            set_field(creator_dod.$last, 'n/a')
            set_field(creator_viaf_dod.$last, 'n/a')
        end
    end

    # Creator role (Publisher, Painter,...)

    if all_match('c.actorInRole.roleActor.$last.term.$last._', '.*\S.*')
        copy_field(c.actorInRole.roleActor.$last.term.$last._, creator_role.$append)
    else
        add_field(creator_role.$append, 'n/a')
    end

    # Flatten creator_display & creator_index

    join_field(tmp_creator_display, " ")
    move_field(tmp_creator_display, creator_display.$append)

    join_field(tmp_creator_index, " ")
    move_field(tmp_creator_index, creator_index.$append)    
end

## Production date

do list(path:_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventDate.displayDate, var:dat)
    copy_field(dat._, production_date.$append)
end

sort_field(production_date)

## Publish image

# This algorithm establishes wether or not a digital representation
# may be published based on copyright rules.
#
#  General rule: date of death artist < current date - 70 years
#
# Since we don't always know the date of death of the artist, we perform
# additional checks in order to tentatively assert the copyright. We
# gracefully degrade over these fields:
#
#  * The LIDO date of death of the longest living contributor to the work.
#  * The VIAF date of death of the longest living contributor to the work.
#  * The production date of the work, that is, the most recent asserted date.
#    * Check the latestDate value (should be ISO compliant)
#    * Check the earliestDate value (should be ISO compliant)
#    * Check the displayDate (Hail mary attempt of determining the date)
#
# When asserting copyright via the production date of the work, we use
# this rule: production date < current date - 150 years.
#
# Assuming a max life expectancy of 90 years, we rule out all works 
# created in the past 150 years (70 after presumable death + 80 years).
# This would rule out the edge case of a creator who died in his 90's, exactly
# 70 years ago and made his first known works in his teenage years.
#
# The algorithm is a two step process:
#
#  1. Clean up the date formatting of fields we're going to check against.
#     They all need to be of the ISO format YYYY. This requires some regex fu.
#  2. Check against the dates according to the algorithm.
#

# This field is what ultimately determines whether an image can be published
# or not. The default assumption is 'false'. We need to prove that we are
# allowed to publish the digital image.

add_field(publish_image, "false")

# This is a 'sentinel' variable. As soon as the copyright has been 
# determined (true), we bail out of the algorithm.

add_field(determined, "false")

# Step 1: Clean out the date formatting ...

set_array(pretty_dod)

do list(path: 'creator_dod', var: 'dod')
    copy_field(dod, tmp_dod)
    if any_match(tmp_dod, '(\d\d\d\d)-(\d\d)-(\d\d)')
        parse_text(tmp_dod, '(\d\d\d\d)-(\d\d)-(\d\d)')
        copy_field(tmp_dod.$first, pretty_dod.$append)
    else 
        copy_field(tmp_dod, pretty_dod.$append)
    end
    remove_field(tmp_dod)
end

set_array(pretty_viaf_dod)

do list(path: 'creator_viaf_dod', var: 'dod')
    copy_field(dod, tmp_dod)
    if any_match(tmp_dod, '(\d\d\d\d)-(\d\d)-(\d\d)')
        parse_text(tmp_dod, '(\d\d\d\d)-(\d\d)-(\d\d)')
        copy_field(tmp_dod.$first, pretty_viaf_dod.$append)
    else 
        copy_field(tmp_dod, pretty_viaf_dod.$append)
    end
    remove_field(tmp_dod)
end

copy_field(_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventDate, dates)

add_field(production_date_copyright, 'n/a')

if all_match(dates.date.latestDate._, '.*\S.*')
    if any_match(dates.date.latestDate._, '(\d\d\d\d)-(\d\d)-(\d\d)')
        parse_text(dates.date.latestDate._, '(\d\d\d\d)-(\d\d)-(\d\d)')
        copy_field(dates.date.latestDate._.$first, tmp_date)
    else 
        copy_field(dates.date.latestDate._, tmp_date)
    end

    if is_number(tmp_date)
        move_field(tmp_date, production_date_copyright)
    else
        remove_field(tmp_date)
    end
end

if all_equal(production_date_copyright, 'n/a')
    if any_match(dates.date.earliestDate._, '(\d\d\d\d)-(\d\d)-(\d\d)')
        parse_text(dates.date.earliestDate._, '(\d\d\d\d)-(\d\d)-(\d\d)')
        copy_field(dates.date.earliestDate._.$first, tmp_date)
    else 
        copy_field(dates.date.earliestDate._, tmp_date)
    end

    if is_number(tmp_date)
        move_field(tmp_date, production_date_copyright)
    else
        remove_field(tmp_date)
    end
end

if all_equal(production_date_copyright, 'n/a')
    set_array(tmp_date)

    do list(path:dates.displayDate, var:date)
        copy_field(date._, tmp_date.$append)
    end

    # The displayDate is often very messy. It's hard to establish
    # an exact year in most cases. Registrators often fall back a fuzzy
    # dating description. It's impossible to cover all possible variations. 
    # We only try to parse the majority of known patterns (80/20)
    #
    #   circa 1900 - circa 1910
    #   circa 1900-circa 1910
    #   circa1900-circa1910
    #   circa1900-circa 1910
    #   circa1900- circa1910
    #   circa1900 -circa1910
    #   circa 1900-circa1910
    #   circa 1900
    #   circa1900
    #   circa (1900)
    #   circa(1900)
    #   -1900
    #   - 1900
    #   1800-1900
    #   1800 - 1900
    #   1800 -1900
    #   1800- 1900
    #   (1800-1900)
    #   (1800 - 1900)
    #   (1800 -1900)
    #   (1800- 1900)

    if all_match(tmp_date.*, "(\(?(?:circa)?\s?(\d\d\d\d)\s?-?\s?)?(?:circa)?\s?(\d\d\d\d)\)?")
        parse_text(tmp_date.*, "(?:\(?(?:circa)?\s?(\d\d\d\d)\s?-?\s?)?(?:circa)?\s?(\d\d\d\d)\)?")
 
        flatten(tmp_date)
        sort_field(tmp_date, numeric: 1)
        copy_field(tmp_date.$last, production_date_copyright)
    end

    remove_field(tmp_date)
end

# Step 2: Actual determination of the copyright starts here ...

if all_equal(determined, "false")
    do list(path: 'pretty_dod', var: 'date')
        if is_number(date)
            if less_than(date, 1948)
                set_field(publish_image, "true")
            end
            set_field(determined, "true")
        end
    end
end

if all_equal(determined, "false")
    do list(path: 'pretty_viaf_dod', var: 'date')
        if is_number(date)
            if less_than(date, 1948)
                set_field(publish_image, "true")
            end
            set_field(determined, "true")
        end
    end
end

if all_equal(determined, "false")
    if is_number(production_date_copyright)
        if less_than(production_date_copyright, 1870)
            set_field(publish_image, "true")
        end
        set_field(determined, "true")
    end
end

# Done. Remove fields. We don't need them anymore.

remove_field(creator_dob)
remove_field(creator_dod)
remove_field(creator_viaf_dod)
remove_field(pretty_dod)
remove_field(pretty_viaf_dod)
remove_field(production_date_copyright)
remove_field(dates)
remove_field(determined)

## Period - use NL field

do list(path:_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.periodName, var:per)
    if all_match('per.term.*.lang', 'nl')
        copy_field('per.term.*._', period.$append)
    end
end

sort_field(period)

## Repository

copy_field('_metadata.administrativeMetadata.0.recordWrap.recordSource.0.legalBodyName.0.appellationValue.0._', 'repository')

## Material

do list(path: '_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventMaterialsTech', var: mat)
    do list(path: 'mat.materialsTech.termMaterialsTech.0.term', var: prefMaterial)
        if all_match('prefMaterial.pref', 'preferred')
            copy_field(prefMaterial._, material.$append)
        end
    end
end


## Dimensions

do list(path:_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet, var:el2)
    do list(path:el2.objectMeasurements.measurementsSet, var:el)
        if all_match('el.measurementType.0._', 'hoogte')
            copy_field(el.measurementValue._, dimensionsh.$append)
            copy_field(el.measurementUnit.0._, dimensionsh.$append)
            join_field(dimensionsh, ' ')
        end
        if all_match('el.measurementType.0._', 'breedte')
            copy_field(el.measurementValue._, dimensionsw.$append)
            copy_field(el.measurementUnit.0._, dimensionsw.$append)
            join_field(dimensionsw, ' ')
        end
        if all_match('el.measurementType.0._', 'diameter')
            copy_field(el.measurementValue._, dimensionsd.$append)
            copy_field(el.measurementUnit.0._, dimensionsd.$append)
            join_field(dimensionsd, ' ')
        end
    end
end

copy_field(dimensionsh, dimensions.$append)
remove_field(dimensionsh)
copy_field(dimensionsw, dimensions.$append)
remove_field(dimensionsw)
join_field(dimensions, ' x ')

append(dimensionsd, " (diameter)")
copy_field(dimensionsd, dimensions.$append)
remove_field(dimensionsd)

## Category

do list(path: '_metadata.descriptiveMetadata.0.objectRelationWrap.subjectWrap.subjectSet.0.subject.subjectConcept.0.term', var: cat)
    if all_match(cat.lang, 'nl')
        copy_field(cat._, artwork_category.$append)
    end
end

# Artwork_type
# Facet
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.objectWorkTypeWrap.objectWorkType', var:t)
    do list(path: 't.term', var:type)
        if all_match('type.pref', 'alternate')
            copy_field(type._, artwork_type.$append)
        end
    end
end
# Display
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.objectWorkTypeWrap.objectWorkType', var:t)
    do list(path: 't.term', var:type)
        if all_match('type.pref', 'preferred')
            copy_field(type._, artwork_type_display.$append)
        end
    end
end

## Artwork_subtype

# Facet

do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.classificationWrap.classification', var:c) 
    do list(path: 'c.term', var:classification)
        if all_match('classification.pref', 'alternate')
            copy_field(classification._, artwork_subtype.$append)
        end
    end
end

# Display

do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.classificationWrap.classification', var:c)
    do list(path: 'c.term', var:classification)
        if all_match('classification.pref', 'preferred')
            copy_field(classification._, artwork_subtype_display.$append)
        end
    end
end

## References

copy_field('_metadata.administrativeMetadata.0.recordWrap.recordInfoSet.0.recordInfoLink.0._', 'references')

## Object_number

copy_field('_metadata.administrativeMetadata.0.recordWrap.recordID.0._', 'object_number')
# copy_field('_metadata.administrativeMetadata.0.recordWrap.recordID.0._', 'id')

## Description

copy_field('_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.0.descriptiveNoteValue.0._', 'description')

if all_match('_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.1.descriptiveNoteValue.0.lang', 'nl')
    copy_field('_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.1.descriptiveNoteValue.0._', 'description')
end

## Work_pid

copy_field('_metadata.objectPublishedID.0._', 'work_pid')

## Data_pid

do list(path: '_metadata.lidoRecID', var:lidoRecID)
    if all_match('lidoRecID.type', 'purl')
        copy_field(lidoRecID._, data_pid)
    end

    if all_match('lidoRecID.type', 'urn')
        copy_field(lidoRecID._, raw)
    end
end

## Representation_pid

copy_field('_metadata.administrativeMetadata.0.resourceWrap.resourceSet.resourceID', 'representation_pid')

## ID

# The ID in Solr is based on the data_pid. The data_pid is converted to a string
# which can be safely used as an identifier in Project Blacklight. The format of
# the ID field looks like this:
#
#   <domain>:<identifier>
#   ex. kmksa:254
#   ex. collectievlaamsegemeenschap:837
#
# Note: the .tld is stripped from the domainname because the . (dot) breaks the
# route matching algoritm.

copy_field('data_pid', 'id')
parse_text('id', '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
replace_all('id.0', '([^.]*)\.[^.]{2,3}(?:\.[^.]{2,3})?$', '$1')
join_field(id, ':')

# Retain only those records that have a workPid
unless all_match('work_pid', 'http://*')
    remove_field('title_display')
    remove_field('creator_role')
    remove_field('creator_display')
    remove_field('creator_index')
    remove_field('creator')
    remove_field('production_date')
    remove_field('period')
    remove_field('repository')
    remove_field('material')
    remove_field('dimensions')
    remove_field('artwork_category')
    remove_field('artwork_type')
    remove_field('artwork_type_display')
    remove_field('artwork_subtype')
    remove_field('artwork_subtype_display')
    remove_field('references')
    remove_field('object_number')
    remove_field('description')
    remove_field('data_pid')
    remove_field('id')
end

# remove all original fields and only retain the ones we set

remove_field('_id')
remove_field('_identifier')
remove_field('_status')
remove_field('_setSpec')
remove_field('_about')
remove_field('_datestamp')
remove_field('_metadata')
remove_field('_resumption')
remove_field('_resumptionToken')