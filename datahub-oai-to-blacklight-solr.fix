# Catmandu Fix script to convert LIDO XML data into JSON data for Solr
# (MSK data version)
#
# USAGE
# Convert to JSON
# catmandu convert OAI --url "http://datahub_ubuntu:8000/oai/" --metadataPrefx oai_lido --handler lido to JSON --pretty 1 --fix oai.fix > out-fix.json && cat out-fix.json
#
# Import into Solr
# catmandu import OAI --url "http://datahub_ubuntu:8000/oai/" --metadataPrefx oai_lido --handler lido --fix oai.fix to pbsolr

# Title - use NL
# Use dutch title if exists, else use English title
do list(path:_metadata.descriptiveMetadata.0.objectIdentificationWrap.titleWrap.titleSet.0.appellationValue, var:el)
    if all_match('el.lang', 'nl')
        copy_field('el._', "title_display")
    end
end
unless all_match(title_display, '.*\S.*')
    do list(path:_metadata.descriptiveMetadata.0.objectIdentificationWrap.titleWrap.titleSet.0.appellationValue, var:el)
        copy_field('el._', "title_display")
    end
end

# Artist (preferred -> creator_display, alternate -> creator_index)

# Set the creator_role array

set_array(creator_role)
set_array(tmp_creators)

do list(path:'_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventActor', var: c)
    set_array(tmp_creator_index)
    set_array(tmp_creator_display)

    # The name of the creator

    do list(path:c.actorInRole.actor.nameActorSet.0.appellationValue, var:creator)
        if all_match('creator.pref', 'alternate')
            copy_field(creator._, tmp_creator_index.$append)
        else
            copy_field(creator._, tmp_creator_display.$append)
        end
        copy_field(creator._, tmp_creators.$append)
    end

    # The qualifier of the creator (Attributed to, Workshop of,...)

    unless all_match('c.actorInRole.attributionQualifierActor.$last._', 'n/a')
        copy_field(c.actorInRole.attributionQualifierActor.$last._, tmp_creator_index.$prepend)
        copy_field(c.actorInRole.attributionQualifierActor.$last._, tmp_creator_display.$prepend)
    end

    copy_field(c.actorInRole.roleActor, tmp_creator_index.$append)
    copy_field(c.actorInRole.roleActor, tmp_creator_display.$append)

    join_field(tmp_creator_index, " ")
    join_field(tmp_creator_display, " ")

    # Add each creator to the field creator if any exists, else remove the field creator
    
    if all_match(tmp_creator_index, '.*\S.*')
        move_field(tmp_creator_index, creator_index.$append)
        move_field(tmp_creator_display, creator_display.$append)
    else
        remove(tmp_creator_index)
        if all_match(tmp_creator_display, '.*\S.*')
            copy_field(tmp_creator_display, creator_index.$append)
            move_field(tmp_creator_display, creator_display.$append)
        else
            remove(tmp_creator_display)
        end
    end


    # The role of the creator (if any, if roleActor is an empty node, add 'n/a' as default)

    unless all_match('c.actorInRole.roleActor.$last.term.$last._', '.*\S.*')
        add_field(creator_role.$append, 'n/a')
    end

    copy_field(c.actorInRole.roleActor.$last.term.$last._, creator_role.$append)
end

set_array(creator)
do list(path: 'tmp_creators', var: c)
    downcase(c)
    lookup_in_store(c, DBI, data_source: "dbi:SQLite:/tmp/import.CREATORS_UTF8.sqlite")
    if all_match(c.viaf_alternate, '.*\S.*')
        copy_field(c.viaf_alternate, creator.$append)
    end
end

remove_field(tmp_creators)

# Production date
do list(path:_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventDate.displayDate, var:dat)
    copy_field(dat._, production_date.$append)
end

sort_field(production_date)

# Period - use NL field
do list(path:_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.periodName, var:per)
    if all_match('per.term.*.lang', 'nl')
        copy_field('per.term.*._', period.$append)
    end
end

sort_field(period)

# Repository
copy_field('_metadata.administrativeMetadata.0.recordWrap.recordSource.0.legalBodyName.0.appellationValue.0._', 'repository')

# Material
do list(path: '_metadata.descriptiveMetadata.0.eventWrap.eventSet.0.event.eventMaterialsTech', var: mat)
    do list(path: 'mat.materialsTech.termMaterialsTech.0.term', var: prefMaterial)
        if all_match('prefMaterial.pref', 'preferred')
            copy_field(prefMaterial._, material.$append)
        end
    end
end


# Dimensions
do list(path:_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet, var:el2)
    do list(path:el2.objectMeasurements.measurementsSet, var:el)
        if all_match('el.measurementType.0._', 'hoogte')
            copy_field(el.measurementValue._, dimensionsh.$append)
            copy_field(el.measurementUnit.0._, dimensionsh.$append)
            join_field(dimensionsh, ' ')
        end
        if all_match('el.measurementType.0._', 'breedte')
            copy_field(el.measurementValue._, dimensionsw.$append)
            copy_field(el.measurementUnit.0._, dimensionsw.$append)
            join_field(dimensionsw, ' ')
        end
        if all_match('el.measurementType.0._', 'diameter')
            copy_field(el.measurementValue._, dimensionsd.$append)
            copy_field(el.measurementUnit.0._, dimensionsd.$append)
            join_field(dimensionsd, ' ')
        end
    end
end

copy_field(dimensionsh, dimensions.$append)
remove_field(dimensionsh)
copy_field(dimensionsw, dimensions.$append)
remove_field(dimensionsw)
join_field(dimensions, ' x ')

append(dimensionsd, " (diameter)")
copy_field(dimensionsd, dimensions.$append)
remove_field(dimensionsd)

# Category
do list(path: '_metadata.descriptiveMetadata.0.objectRelationWrap.subjectWrap.subjectSet.0.subject.subjectConcept.0.term', var: cat)
    if all_match(cat.lang, 'nl')
        copy_field(cat._, artwork_category.$append)
    end
end

# Artwork_type
# Facet
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.objectWorkTypeWrap.objectWorkType', var:t)
    do list(path: 't.term', var:type)
        if all_match('type.pref', 'alternate')
            copy_field(type._, artwork_type.$append)
        end
    end
end
# Display
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.objectWorkTypeWrap.objectWorkType', var:t)
    do list(path: 't.term', var:type)
        if all_match('type.pref', 'preferred')
            copy_field(type._, artwork_type_display.$append)
        end
    end
end

# Artwork_subtype
# Facet
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.classificationWrap.classification', var:c) 
    do list(path: 'c.term', var:classification)
        if all_match('classification.pref', 'alternate')
            copy_field(classification._, artwork_subtype.$append)
        end
    end
end
# Display
do list(path: '_metadata.descriptiveMetadata.0.objectClassificationWrap.classificationWrap.classification', var:c)
    do list(path: 'c.term', var:classification)
        if all_match('classification.pref', 'preferred')
            copy_field(classification._, artwork_subtype_display.$append)
        end
    end
end

# References
copy_field('_metadata.administrativeMetadata.0.recordWrap.recordInfoSet.0.recordInfoLink.0._', 'references')

# Object_number
copy_field('_metadata.administrativeMetadata.0.recordWrap.recordID.0._', 'object_number')
# copy_field('_metadata.administrativeMetadata.0.recordWrap.recordID.0._', 'id')

# Description
copy_field('_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.0.descriptiveNoteValue.0._', 'description')

if all_match('_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.1.descriptiveNoteValue.0.lang', 'nl')
    copy_field('_metadata.descriptiveMetadata.0.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.1.descriptiveNoteValue.0._', 'description')
end

# Work_pid
copy_field('_metadata.objectPublishedID.0._', 'work_pid')

# Data_pid
do list(path: '_metadata.lidoRecID', var:lidoRecID)
    if all_match('lidoRecID.type', 'purl')
        copy_field(lidoRecID._, data_pid)
    end

    if all_match('lidoRecID.type', 'urn')
        copy_field(lidoRecID._, raw)
    end
end

# Representation_pid
copy_field('work_pid', 'representation_pid')
parse_text('representation_pid', '(.*)/collection/work/id/(.*)')
join_field('representation_pid', '/collection/work/representation/')

# ID
#
# The ID in Solr is based on the data_pid. The data_pid is converted to a string
# which can be safely used as an identifier in Project Blacklight. The format of
# the ID field looks like this:
#
#   <domain>:<identifier>
#   ex. kmksa:254
#   ex. collectievlaamsegemeenschap:837
#
# Note: the .tld is stripped from the domainname because the . (dot) breaks the
# route matching algoritm.

copy_field('data_pid', 'id')
parse_text('id', '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
replace_all('id.0', '([^.]*)\.[^.]{2,3}(?:\.[^.]{2,3})?$', '$1')
join_field(id, ':')

# Retain only those records that have a workPid
unless all_match('work_pid', 'http://*')
    remove_field('title_display')
    remove_field('creator_role')
    remove_field('creator_display')
    remove_field('creator_index')
    remove_field('creator')
    remove_field('production_date')
    remove_field('period')
    remove_field('repository')
    remove_field('material')
    remove_field('dimensions')
    remove_field('artwork_category')
    remove_field('artwork_type')
    remove_field('artwork_type_display')
    remove_field('artwork_subtype')
    remove_field('artwork_subtype_display')
    remove_field('references')
    remove_field('object_number')
    remove_field('description')
    remove_field('data_pid')
    remove_field('id')
end

# remove all original fields and only retain the ones we set
remove_field('_id')
remove_field('_identifier')
remove_field('_status')
remove_field('_setSpec')
remove_field('_about')
remove_field('_datestamp')
remove_field('_metadata')
remove_field('_resumption')
remove_field('_resumptionToken')