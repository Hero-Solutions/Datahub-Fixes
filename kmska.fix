# Catmandu Fix

# Institution: Royal Museum for Fine Arts Antwerp
# Description: Converts TMS datastructures to LIDO 1.0
# Created: 8/11/2017



### Prepare an intermediate structure

# Retain only those records where DepartmentID equals 1

    select all_match(DepartmentID, '1')

# Copy relevant fields in order to create a dedicated LIDO structure
# Some fields, for example ObjectNumber, ObjectID, DateBegin, DateEnd, Dated and Medium, are obtained from the CITvgsrpObjTombstoneD_RO table in MySQL
# Additional data is obtained from SQLite database files

    # Identifiers

    copy_field(ObjectNumber, or_record.object_number.local)

    copy_field(ObjectID, or_record.object_number.tms)

    copy_field(ObjectNumber, or_record.object_number.datapid)
    lookup_in_store(or_record.object_number.datapid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.datapids.sqlite')
    move_field(or_record.object_number.datapid.dataPid, or_record.object_number.pid.dataPid)
    remove_field(or_record.object_number.datapid)

    copy_field(ObjectNumber, or_record.object_number.workpid)
    lookup_in_store(or_record.object_number.workpid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.workpids.sqlite')
    move_field(or_record.object_number.workpid.workPid, or_record.object_number.pid.workPid)
    remove_field(or_record.object_number.workpid)

    copy_field(ObjectNumber, or_record.object_number.representationpid)
    lookup_in_store(or_record.object_number.representationpid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.representationpids.sqlite')
    move_field(or_record.object_number.representationpid.representationPid, or_record.object_number.pid.representationPid)
    remove_field(or_record.object_number.representationpid)

    # objectWrap

    copy_field(ObjectID, or_record.objectWrap.db)
    lookup_in_store(or_record.objectWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.objects.sqlite')

    # classificationWrap

    copy_field(ObjectID, or_record.classificationWrap.db)
    lookup_in_store(or_record.classificationWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.classifications.sqlite')

    # subjectWrap

    copy_field(ObjectID, or_record.subjectWrap.db)
    lookup_in_store(or_record.subjectWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.subjects.sqlite')

    # materialWrap

    copy_field(ObjectID, or_record.materialWrap.db)
    lookup_in_store(or_record.materialWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.materials.sqlite')

    # techniqueWrap

    copy_field(ObjectID, or_record.techniqueWrap.db)
    lookup_in_store(or_record.techniqueWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.techniques.sqlite')

    # title

    copy_field(ObjectNumber, or_record.titleWrap.db)
    lookup_in_store(or_record.titleWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.objtitles.sqlite')

    # location

    copy_field(ObjectID, or_record.location.db)
    lookup_in_store(or_record.location.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.locations.sqlite')

    # textEntries

    copy_field(ObjectID, or_record.textEntries.db)
    lookup_in_store(or_record.textEntries.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.textentries.sqlite')

    # objectMeasurements

    copy_field(ObjectID, or_record.objectMeasurements.db)
    lookup_in_store(or_record.objectMeasurements.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.dimensions.sqlite')

    # production actor (production)

    copy_field(ObjectID, or_record.constituentWrap.db)
    lookup_in_store(or_record.constituentWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.constituents.sqlite')

    # production date (production)

    unless all_equal(DateBegin, '0')
        copy_field(DateBegin, or_record.date.begin)
    end

    unless all_equal(DateEnd, '0')
        copy_field(DateEnd, or_record.date.end)
    end

    copy_field(Dated, or_record.date.display)

    trim(or_record.date.begin)
    trim(or_record.date.end)
    trim(or_record.date.display)

    # period

    copy_field(ObjectID, or_record.periodName)
    lookup_in_store(or_record.periodName, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.periods.sqlite')

    # place (not yet added)

    # eventMaterialsTech

    copy_field(Medium, or_record.eventMaterialsTech.display)

    # subjectConcept

    copy_field(ObjectID, or_record.iconclass.db)
    lookup_in_store(or_record.iconclass.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.iconclass.sqlite')

    # relatedWorksWrap

    copy_field(ObjectID, or_record.relationWrap.db)
    lookup_in_store(or_record.relationWrap.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.relations.sqlite')

    # linkLibrary

    copy_field(UserNumber1, or_record.linkLibrary)

    # recordSource

    copy_field(ObjectID, or_record.department.db)
    lookup_in_store(or_record.department.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.departments.sqlite')

    # resourceWrap

    copy_field(ObjectNumber, or_record.iiif_manifest)
    lookup_in_store(or_record.iiif_manifest, DBI, data_source: 'dbi:SQLite:/tmp/import.iiif_manifests.sqlite')

    # Set placeholder if no manifest exists (look up 'placeholder_manifest' in sqlite)

    unless all_match(or_record.iiif_manifest.manifest, '.*\S.*')

        set_field(or_record.iiif_manifest, 'placeholder_manifest')
        lookup_in_store(or_record.iiif_manifest, DBI, data_source: 'dbi:SQLite:/tmp/import.iiif_manifests.sqlite')

    end

    # translations

    copy_field(ObjectID, or_record.translations.db)
    lookup_in_store(or_record.translations.db, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.translations.sqlite')


# Remove all fields from CITvgsrpObjTombstoneD_RO, retaining only the ones necessary to create the LIDO structure

    retain(or_record)



### Mapping to lido structure

# Mapping Facets
# ---------------------------------------------------------------------------------------------------------------------------------------------------
# TMS - MySQL                             LIDO                                                VKC                     Invulboek veld
#                                             lido:lidoRecID
#   vdatapids.dataPid                             type: purl                                                              waarde databanknummer
#                                                 type: urn
#   vworkpids.workPid                         lido:objectPublishedID                              Work PURL               waarde objectnummer
#                                             lido:category
#                                                 lido:conceptID
#                                                 lido:term
#                                             lido:objectWorkType
#                                                 lido:conceptID
#   vobjects.TermID                                  pref: preferred
#                                                    pref: alternate                                                      identificatie objectnaam
#                                                 lido:term
#                                                    pref: preferred
#   vobjects.object                                      lang: nl                                 Subtype                 term objectnaam
#                                                    pref: alternate                              Subtype
#                                             lido:classification
#                                                 type: object-category
#                                                    lido:conceptID
#   vclassifications.ClassificationID                     pref: preferred
#                                                         pref: alternate                                                 identificatie
#                                                    lido:term
#   vclassifications.classification_nl                    pref: preferred / lang: nl              Type                    term
#                                                         pref: alternate / lang: nl              Type
#   vclassifications.classification_en                    lang: en
#   vclassifications.classification_fr                    lang: fr
#                                             lido:titleSet
#                                                 lido:appellationValue
#   vobjtitles.title                                  lang: en                                                            titel
#   vobjtitles.title                                  lang: nl                                                            titel
#                                                 lido:sourceAppellation
#   vobjtitles.titleid                                lang: en
#   vobjtitles.titleid                                lang: nl
#                                             lido:repositorySet
#                                                 lido:repositoryName
#   vdepartments.DepartmentID                         lido:legalBodyID
#                                                     lido:legalBodyName
#   vdepartments.department                               lang: nl                                Instelling              naam bewaarinstelling
#                                                 lido:workID
#   CITvgsrpObjTombstoneD_RO.ObjectNumber             type: object-number                         Inventarisnummer        waarde objectnummer
#                                                 lido:repositoryLocation
#   vlocations.room_nl                                lang: nl
#                                                     lang: en
#                                             lido:objectDescriptionSet
#                                                     lido:descriptiveNoteValue
#   vtextentries.textEntry                                lang: nl                                Beschrijving            korte beschrijving
#   vtextentries.textEntry                                lang: en
#                                             lido:objectMeasurementsSet
#   vdimensions.display                           lido:displayObjectMeasurements
#                                                 lido:objectMeasurements
#                                                     lido:measurementsSet
#   vdimensions.type                                      lido:measurementType                                            dimensie afmeting
#   vdimensions.unit                                      lido:measurementUnit                    Dimensies               eenheid afmeting
#   vdimensions.dimension                                 lido:measurementValue                   Dimensies               waarde afmeting
#   vdimensions.element                               lido:extentMeasurements                                             onderdeel afmeting
#                                             lido:eventType
#                                                 lido:term
#                                                     production
#                                                         lido:eventActor
#                                                             lido:actorID
#   vconstituents.ConstituentID                                   type: local
#                                                                 type: purl                                              identificatie vervaardiger
#                                                             lido:nameActorSet
#   vconstituents.DisplayName                                     pref: preferred                 Vervaardiger            naam vervaardiger
#                                                                 pref: alternate
#                                                                 label: name-without-comma
#   vconstituents.AlphaSort                                       label: name-with-comma
#                                                             lido:vitalDatesActor
#   vconstituents.BeginDateISO                                    lido:earliestDate
#   vconstituents.EndDateISO                                      lido:latestDate
#                                                             lido:roleActor
#   vconstituents.role_nl                                         lang: nl                        Vervaardiger            rol vervaardiger
#   vconstituents.role_en                                         lang: en
#   vconstituents.role_fr                                         lang: fr
#                                                             lido:attributionQualifierActor
#   vconstituents.role_nl                                         lang: nl                        Vervaardiger            kwalificatie vervaardiger
#   vconstituents.role_en                                         lang: en
#   vconstituents.role_fr                                         lang: fr
#                                                         lido:eventDate
#   CITvgsrpObjTombstoneD_RO.Dated                            lido:displayDate                    Datering
#                                                             lido:date
#   CITvgsrpObjTombstoneD_RO.DateBegin                            lido:earliestDate                                       begindatum
#   CITvgsrpObjTombstoneD_RO.DateEnd                              lido:latestDate                                         einddatum
#                                                         lido:periodName
#                                                             lido:term
#   vperiods.term                                                 lang: nl
#   vtranslations.textEntry                                       lang: en
#   vtranslations.textEntry                                       lang: fr
#                                                         lido:eventMaterialsTech
#                                                             lido:termMaterialsTech
#                                                                 type: material
#                                                                     lido:conceptID
#   vmaterials.TermID                                                     pref: preferred
#                                                                         pref: alternate                                 identificatie materiaal
#                                                                     lido:term
#   vmaterials.material                                                   pref: preferred         Materiaal               term materiaal
#                                                                         pref: alternate
#                                                                 type: technique
#                                                                     lido:conceptID
#   vtechniques.TermID                                                    pref: preferred
#                                                                     lido:term
#   vtechniques.technique                                                 pref: preferred
#                                                             lido:displayMaterialsTech
#   Objects.Medium                                                lang: nl
#   vtranslations.textEntry                                       lang: en
#   vtranslations.textEntry                                       lang: fr
#                                             lido:objectRelationWrap
#                                                 lido:subject
#                                                     type: content-motif-general
#                                                         lido:subjectConcept
#                                                             lido:conceptID
#   vsubjects.TermID                                              pref: preferred
#                                                                 pref: alternate                                         identificatie hoofdmotief
#                                                             lido:term
#                                                                 pref: preferred
#   vsubjects.subject                                                 lang: nl                    Onderwerp               term hoofdmotief
#                                                                 pref: alternate                 Onderwerp
#                                                     type: content-motif-specific
#                                                     source: Iconclass
#                                                         lido:subjectConcept
#   viconclass                                                lido:conceptID                                              identificatie afgebeeld concept
#   viconclass                                                lido:term                                                   term afgebeeld concept
#                                             lido:relatedWorksWrap
#                                                 lido:relatedWorkSet
#   vrelations.numbering                              sortorder
#                                                         lido:relatedWork
#                                                             lido:objectID
#   vrelations.relatedObjectNumber                                type: local
#                                                                 type: oai
#                                                         lido:relatedWorkRelType
#   vrelations.relationshipID1(2)                             lido:conceptID
#                                                                 type: local
#                                                                 type: URI
#   vrelations.relationship                                   lido:term
#                                                     no sortorder
#                                                         lido:relatedWork
#   Objects.UserNumber1                                       lido:objectWebResource
#                                             lido:rightsWorkWrap
#                                                 lido:rightsType
#                                                     lido:conceptID                                                      identificatie rechten werk
#   vconstituents.copyright                           lido:term                                                           term rechten werk
#   vconstituents.copyright                       lido:creditLine
#                                             lido:recordWrap
#                                                 lido:recordID
#   vdatapids.dataPid                                 type: global                                Data PURL               waarde databanknummer
#   CITvgsrpObjTombstoneD_RO.ObjectID                 type: local                                                         waarde databanknummer
#                                                 lido:recordType
#                                                     lido:conceptID
#                                                     lido:term
#                                                 lido:recordSource
#   vdepartments.DepartmentID                         lido:legalBodyID                                                    identificatie data provider
#   vdepartments.department                           lido:legalBodyName                                                  naam data provider
#                                                     lido:legalBodyWeblink
#                                             lido:resourceWrap
#   vrepresentationpids.representationPid         lido:resourceID
#                                                 lido:resourceRepresentation
#   vrepresentationpids.representationPid             lido:linkResource



### LIDO lidoRecID

    # ID
    #
    # The ID in Solr is based on the data_pid. The data_pid is converted to a string
    # which can be safely used as an identifier in Project Blacklight. The format of
    # the ID field looks like this:
    #
    #   oai:datahub.vlaamsekunstcollectie.be:<domain>:<identifier>
    #   ex. oai:datahub.vlaamsekunstcollectie.be:kmksa.be:254
    #   ex. oai:datahub.vlaamsekunstcollectie.be:collectievlaamsegemeenschap.be:837
    #
    # Note: the .tld is stripped from the domainname because the . (dot) breaks the
    # route matching algoritm.

    # Create datahub record ID

    copy_field('or_record.object_number.pid.dataPid', 'or_record.object_number.pid.oaiPid')
    parse_text('or_record.object_number.pid.oaiPid', '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
    join_field('or_record.object_number.pid.oaiPid', ':')
    prepend('or_record.object_number.pid.oaiPid', 'oai:datahub.vlaamsekunstcollectie.be:')

    # Add datapid from TMS as LIDO lidoRecID (type:purl)

    lido_baseid(
        lidoRecID,
        or_record.object_number.pid.dataPid,
        -type: purl,
        -source: 'Koninklijk Museum voor Schone Kunsten Antwerpen',
        -label: dataPID,
        -pref: alternate
    )

    # Add the created datahub record ID as LIDO lidoRecID (type:urn)

    lido_baseid(
        lidoRecID,
        or_record.object_number.pid.oaiPid,
        -type: urn,
        -source: 'Vlaamse Kunstcollectie - Arthub Flanders',
        -label: dataPID,
        -pref: preferred
    )



### LIDO objectPublishedID

    # Add workpid from TMS as LIDO objectPublishedID

    lido_baseid(
        objectPublishedID,
        or_record.object_number.pid.workPid,
        -source: 'Koninklijk Museum voor Schone Kunsten Antwerpen',
        -type: purl,
        -label: workPID
    )



### LIDO category

    # Create CIDOCCategoryTerm and CIDOCCategoryURI

    add_field(or_record.CIDOCCategoryTerm, 'Man-Made Object')
    add_field(or_record.CIDOCCategoryURI, 'http://www.cidoc-crm.org/Entity/e22-man-made-object/version-6.1')

    # Add the created CIDOCCategoryTerm to LIDO category as LIDO term along with the CIDOCCategoryURI as LIDO conceptID

    lido_term(
        category,
        or_record.CIDOCCategoryTerm,
        -conceptid: or_record.CIDOCCategoryURI,
        -type: purl,
        -source: cidoc-crm
    )



### LIDO descriptiveMetadata

## LIDO objectClassificationWrap

# LIDO objectWorkType

    # We'll have multiple terms: the corresponding value from the AAT vocabulary (type:alternate) and the value from TMS (type:preferred)

    # Loop over the different object terms from TMS

    do list(path:or_record.objectWrap.db.objects, var:o)

        # Add each object term from TMS to LIDO objectWorkType as LIDO term (type:preferred) along with the termID from TMS as LIDO conceptID (type:preferred)

        lido_term(
            descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$append,
            o.object,
            -conceptid: o.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Add the translation for the object term from the translations vocabulary, this is not (yet) retrievable via TMS

        copy_field(o.object, o.object_name_translation)

        lookup_in_store(o.object_name_translation, DBI, data_source: "dbi:SQLite:/tmp/import.Translations.sqlite")

        if all_match(o.object_name_translation._id, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                o.object_name_translation.translation,
                -pref: alternate,
                -lang: en
            )

        end

        remove_field(o.object_name_translation)

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(o.object, o.object_aat)
        lookup_in_store(o.object_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO objectWorkType as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(o.object_aat.aatterm, '.*\S.*')

            if all_match(o.object_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                    o.object_aat.aatterm,
                    -conceptid: o.object_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.$last,
                    o.object_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )                

            end

        end

    end

# LIDO classification [type="object-category"]

    # We'll have multiple terms for the type "object-category": the corresponding value from the AAT vocabulary (pref:alternate) and the value from TMS (pref:preferred)

    # Loop over the different classification terms from TMS

    do list(path:or_record.classificationWrap.db.classifications, var:c)

        # Add each classification term from TMS to LIDO classification as LIDO term (pref:preferred) along with the classificationID from TMS as LIDO conceptID (pref:preferred)

        lido_term(
            descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$append,
            c.classification_nl,
            -conceptid: c.ClassificationID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        copy_field(c.classification_en, descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.term.$append._)
        add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.term.$last.pref, "preferred")
        add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.term.$last.lang, "en")

        copy_field(c.classification_fr, descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.term.$append._)
        add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.term.$last.pref, "preferred")
        add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.term.$last.lang, "fr")

        # Add type of LIDO classification

        add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.type, "object-category")

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(c.Classification, c.classification_aat)
        lookup_in_store(c.classification_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO classification as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(c.classification_aat.aatterm, '.*\S.*')

            if all_match(c.classification_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last,
                    c.classification_aat.aatterm,
                    -conceptid: c.classification_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last,
                    c.classification_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )                

            end

            # Add type of LIDO classification

            add_field(descriptiveMetadata.objectClassificationWrap.classificationWrap.classification.$last.type, "object-category")

        end

    end


## LIDO objectIdentificationWrap

# LIDO titleSet

    # Loop over the different titles from TMS

    do list(path:or_record.titleWrap.db.objtitles, var:t)

        # Use TitleTypeID 1 (titles)

        if all_match(t.titletypeid, '1')

            # Remove unnecessary whitespaces

            trim(t.title)
            trim(t.titleid)

            # Add each title from TMS to LIDO titleSet as LIDO appellationValue along with the titleID from TMS as LIDO sourceAppellation

            copy_field(t.title, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$append._)
            set_field(descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$last.pref, 'preferred')
            copy_field(t.language, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.appellationValue.$last.lang)
            copy_field(t.titleid, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.sourceAppellation.$append._)
            copy_field(t.language, descriptiveMetadata.objectIdentificationWrap.titleWrap.titleSet.sourceAppellation.$last.lang)

        end

    end

# LIDO repositoryName

    # Add department ID from TMS to LIDO repositoryName as LIDO legalBodyID

    lido_baseid(
        descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$append.repositoryName.legalBodyID,
        or_record.department.db.DepartmentID,
        -type: local,
        -source: TMS
    )

    # Add department from TMS to LIDO repositoryName as LIDO legalBodyName

    lido_basenameset(
        descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryName.legalBodyName,
        or_record.department.db.department,
        value_lang: nl
    )

    if all_match(or_record.department.db.department, 'Koninklijk Museum voor Schone Kunsten Antwerpen')

        set_field(or_record.institution_translation, 'Royal Museum of Fine Arts Antwerp')

        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryName.legalBodyName,
            or_record.institution_translation,
            value_lang: en
        )

        remove_field(or_record.institution_translation)

    end

    if all_match(or_record.legalBodyName, '.*\S.*')

        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.repositoryName.legalBodyName,
            or_record.legalBodyName
        )

    end

# LIDO workID

    # Add object number from TMS as LIDO workID

    lido_baseid(
        descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.workID,
        or_record.object_number.local,
        -type: object-number
    )

# LIDO repositoryLocation

    # Add "Currently on display" to LIDO repositoryLocation as LIDO namePlaceSet if location is present in TMS

    if all_match(or_record.location.db.room_nl, '.*\S.*')

        set_field(or_record.current_location, 'Te zien op zaal')

        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryLocation.namePlaceSet.$append,
            or_record.current_location,
            -value_lang: nl
        )

        set_field(or_record.current_location, 'Currently on display')

        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryLocation.namePlaceSet.$last,
            or_record.current_location,
            -value_lang: en
        )

    else

        set_field(or_record.current_location, 'In depot / in bruikleen')

        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryLocation.namePlaceSet.$append,
            or_record.current_location,
            -value_lang: nl
        )

        set_field(or_record.current_location, 'In depot / on loan')

        lido_basenameset(
            descriptiveMetadata.objectIdentificationWrap.repositoryWrap.repositorySet.$last.repositoryLocation.namePlaceSet.$last,
            or_record.current_location,
            -value_lang: en
        )

    end

    remove_field(or_record.current_location)

# LIDO objectDescriptionSet

    # Loop over the different text entries from TMS

    do list(path:or_record.textEntries.db.textentries, var:t)

        # Only retain text type ID 107

        if all_match(t.textTypeID, '107')

            # Add each text entry from TMS (if present) to LIDO objectDescriptionSet as LIDO descriptiveNoteValue

            if all_match(t.textEntry, '.*\S.*')

                # Add a new, empty LIDO objectDescriptionSet field

                add_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$append)

                # Remove unnecessary whitespaces

                trim(t.textEntry)

                # Add the Dutch text entry to last created LIDO objectDescriptionSet

                if all_match(t.languageid, 2)

                    copy_field(t.textEntry, descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue._)

                    set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue.lang, 'nl')

                end

                # Add the English text entry to last created LIDO objectDescriptionSet

                if all_match(t.languageid, 1)

                    copy_field(t.textEntry, descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue._)

                    set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue.lang, 'en')

                end

                # Add the French text entry to last created LIDO objectDescriptionSet

                if all_match(t.languageid, 3)

                    copy_field(t.textEntry, descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue._)

                    set_field(descriptiveMetadata.objectIdentificationWrap.objectDescriptionWrap.objectDescriptionSet.$last.descriptiveNoteValue.lang, 'fr')

                end

            end

        end

    end

# LIDO objectMeasurementsSet

    # Loop over the different dimensions from TMS

    do list(path:or_record.objectMeasurements.db.dimensions, var:d)

        # Add a new, empty LIDO objectMeasurementsSet field

        add_field(descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$append)

        ## Create the LIDO fields

        # Add display of each dimension from TMS (if present) as LIDO displayObjectMeasurements

        if all_match(d.display, '.*\S.*')

            copy_field(d.display, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.displayObjectMeasurements._)

        end

        # Add type of each dimension from TMS (if present) as LIDO measurementType

        if all_match(d.type, '.*\S.*')

            copy_field(d.type, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementType._)

        end

        # Add unit of each dimension from TMS (if present) as LIDO measurementUnit

        if all_match(d.unit, '.*\S.*')

            copy_field(d.unit, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementUnit._)

        end

        # Add value of each dimension from TMS (if present) as LIDO measurementValue

        if all_match(d.dimension, '.*\S.*')

            copy_field(d.dimension, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.measurementsSet.measurementValue._)

        end

        # Add element of each dimension from TMS (if present) as LIDO extentMeasurements

        if all_match(d.element, '.*\S.*')

            copy_field(d.element, descriptiveMetadata.objectIdentificationWrap.objectMeasurementsWrap.objectMeasurementsSet.$last.objectMeasurements.extentMeasurements._)

        end

    end


## LIDO eventWrap

# LIDO eventType [eventType/term="production"]

    # Create event_type

    add_field(or_record.event_type, "production")

    # Add the created event type to LIDO eventType
    
    lido_term(
        descriptiveMetadata.eventWrap.eventSet.$append.event.eventType,
        or_record.event_type
    )

# LIDO eventActor [eventType/term="production"]

    # We'll have multiple appellationValues and actorIDs for the same actor: the corresponding values from the creators vocabulary and the values from TMS

    # Determine which roles from TMS should be added as qualifier

    set_array(qualifiers, "atelier van", "kopie naar", "navolger van", "omgeving van", "school van", "toegeschreven aan", "x")
    set_array(qualifiers_en, "workshop of", "copy after", "follower of", "circle of", "school of", "attributed to")
    set_array(qualifiers_fr, "atelier de", "copie d'après", "disciple de", "cercle de", "école de", "attribué à")

    # Loop over the different constituents from TMS

    do list(path:or_record.constituentWrap.db.constituents, var:c)

        # Remove unnecessary whitespaces

        trim(c.BeginDateISO)
        trim(c.EndDateISO)
        trim(c.role_nl)
        trim(c.role_en)
        trim(c.role_fr)

        # Add the display name of each constituent from TMS to LIDO eventActor as LIDO appellationValue (pref:preferred)
        # along with the constituentID from TMS as LIDO actorID (source:TMS),
        # the BeginDateISO from TMS as LIDO earliestDate,
        # the EndDateISO from TMS as LIDO latestDate and,
        # if determined before as qualifier, add the role from TMS as LIDO attributionQualifierActor
        # else, add the role from TMS as LIDO roleActor

        unless all_match(c.role_nl, 'vroegere toeschrijving')

            if in(c.role_nl, qualifiers)
                lido_actor(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append,
                    c.ConstituentID,
                    c.DisplayName,
                    -name_lang: nl,
                    -id_source: TMS,
                    -id_type: local,
                    -qualifier: c.role_nl,
                    -name_pref: preferred
                )
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.attributionQualifierActor.$last.lang, "nl")
            else
                lido_actor(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$append,
                    c.ConstituentID,
                    c.DisplayName,
                    -name_lang: nl,
                    -id_source: TMS,
                    -id_type: local,
                    -birthdate: c.BeginDateISO,
                    -deathdate: c.EndDateISO,
                    -role: c.role_nl,
                    -name_pref: preferred
                )
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.roleActor.term.$last.lang, "nl")
            end

        end

        unless all_match(c.role_en, "formerly attributed to")

            if in(c.role_en, qualifiers_en)
                copy_field(c.role_en, descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.attributionQualifierActor.$append._)
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.attributionQualifierActor.$last.lang, "en")
            else
                copy_field(c.role_en, descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.roleActor.term.$append._)
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.roleActor.term.$last.lang, "en")
            end

        end

        unless all_match(c.role_fr, "Ancienne attribution à")

            if in(c.role_fr, qualifiers_fr)
                copy_field(c.role_fr, descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.attributionQualifierActor.$append._)
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.attributionQualifierActor.$last.lang, "fr")
            else
                copy_field(c.role_fr, descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.roleActor.term.$append._)
                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.roleActor.term.$last.lang, "fr")
            end

        end

        # Retrieve the corresponding values from the creators vocabulary

        unless all_match(c.role_nl, 'vroegere toeschrijving')
            copy_field(c.DisplayName, c.creator.pid)
            downcase(c.creator.pid)
            lookup_in_store(c.creator.pid, DBI, data_source: "dbi:SQLite:/tmp/import.CREATORS_UTF8.sqlite")
        end

        # Add the corresponding display name from the creators vocabulary (if present) to LIDO eventActor as LIDO appellationValue (type:alternate)

        if all_match(c.creator.pid._id, '.*\S.*')

            lido_basenameset(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.nameActorSet.$last,
                c.creator.pid.display_name,
                -value_lang: nl,
                -value_pref: alternate
            )

        end

        # Add the corresponding VIAF URI from the creators vocabulary (if present) to LIDO eventActor as LIDO actorID (source:VIAF)

        if all_match(c.creator.pid.viaf_uri, '.*\S.*')

            replace_all(c.creator.pid.viaf_uri, 'http://(.*)', 'https://$1')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.viaf_uri,
                -source: VIAF,
                -type: purl
            )

        end

        # Add the corresponding RKD URI from the creators vocabulary (if present) to LIDO eventActor as LIDO actorID (source:RKD)

        if all_match(c.creator.pid.rkd_uri, '.*\S.*')

            replace_all(c.creator.pid.rkd_uri, 'http://(.*)', 'https://$1')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.rkd_uri,
                -source: RKD,
                -type: purl
            )

        end

        # Add the corresponding Wikidata URI from the creators vocabulary (if present) to LIDO eventActor as LIDO actorID (source:Wikidata)

        if all_match(c.creator.pid.wikidata_uri, '.*\S.*')

            replace_all(c.creator.pid.wikidata_uri, 'http://(.*)', 'https://$1')

            lido_baseid(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.actorID,
                c.creator.pid.wikidata_uri,
                -source: Wikidata,
                -type: purl
            )

        end

        # Creator name notation

        unless all_match(c.role_nl, 'vroegere toeschrijving')

            if all_match(c.DisplayName, '.*\S.*')

                lido_basenameset(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.nameActorSet.$last,
                    c.DisplayName,
                    -value_pref: alternate,
                    -value_lang: nl
                )

                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.nameActorSet.$last.appellationValue.$last.label, "name-without-comma")

            end

            if all_match(c.AlphaSort, '.*\S.*')

                lido_basenameset(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.nameActorSet.$last,
                    c.AlphaSort,
                    -value_pref: alternate,
                    -value_lang: nl
                )

                add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventActor.$last.actorInRole.actor.nameActorSet.$last.appellationValue.$last.label, "name-with-comma")

            end

        end

    end

    # Remove the created field qualifiers

    remove_field(qualifiers)
    remove_field(qualifiers_en)
    remove_field(qualifiers_fr)

# LIDO displayDate [eventType/term="production"]

    # Add display date from TMS (if present) as LIDO displayDate

    if all_match(or_record.date.display, '.*\S.*')

        lido_basevalue(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.displayDate,
            or_record.date.display
        )

    end

# LIDO date [eventType/term="production"]

    # Add begin end end date from TMS (if present) as respectively LIDO earliestDate and LIDO latestDate

    if all_match(or_record.date.begin, '.*\S.*')

        if all_match(or_record.date.end, '.*\S.*')

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -earliest_date: or_record.date.begin,
                -latest_date: or_record.date.end
            )

        else

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -earliest_date: or_record.date.begin
            )

        end

    else

        if all_match(or_record.date.end, '.*\S.*')

            lido_date(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventDate.date,
                -latest_date: or_record.date.end
            )

        end

    end

# LIDO periodName [eventType/term="production"]

    # Add period from TMS as LIDO periodName

    lido_term(
        descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$append,
        or_record.periodName.term,
        -pref: preferred,
        -lang: nl
    )

    do list(path:or_record.translations.db.translations, var:t)

        if all_match(t.textTypeID, '124')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last,
                t.textEntry,
                -pref: preferred,
                -lang: en
            )

        end

        if all_match(t.textTypeID, '118')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last,
                t.textEntry,
                -pref: preferred,
                -lang: fr
            )

        end

        if all_match(t.textTypeID, '144')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last,
                t.textEntry,
                -pref: preferred,
                -lang: de
            )

        end

        if all_match(t.textTypeID, '145')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last,
                t.textEntry,
                -pref: preferred,
                -lang: es
            )

        end

        if all_match(t.textTypeID, '146')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last,
                t.textEntry,
                -pref: preferred,
                -lang: it
            )

        end

        if all_match(t.textTypeID, '147')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last,
                t.textEntry,
                -pref: preferred,
                -lang: ru
            )

        end

        if all_match(t.textTypeID, '148')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.periodName.$last,
                t.textEntry,
                -pref: preferred,
                -lang: zh
            )

        end

    end

# LIDO namePlaceSet [eventType/term="production"]

    # Not yet added

# LIDO termMaterialsTech [eventType/term="production"]

    # We'll have multiple terms: the corresponding value from the AAT vocabulary (type:alternate) and the value from TMS (type:preferred)

    # Loop over the different material terms from TMS

    do list(path:or_record.materialWrap.db.materials, var:m)

        add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append.type, "material")

        # Add each material term from TMS to LIDO termMaterialsTech as LIDO term (type:preferred) along with the termID from TMS as LIDO conceptID (type:preferred)
        
        lido_term(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
            m.material,
            -conceptid: m.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        copy_field(m.material, m.material_translation)

        lookup_in_store(m.material_translation, DBI, data_source: "dbi:SQLite:/tmp/import.Translations.sqlite")

        if all_match(m.material_translation._id, '.*\S.*')

            lido_term(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                m.material_translation.translation,
                -pref: alternate,
                -lang: en
            )

        end

        remove_field(m.material_translation)

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(m.subject, m.material_aat)
        downcase(m.material_aat)
        lookup_in_store(m.material_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO termMaterialsTech as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(m.material_aat.aatterm, '.*\S.*')

            if all_match(m.material_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    m.material_aat.aatterm,
                    -conceptid: m.material_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    m.material_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

    # Loop over the different technique terms from TMS

    do list(path:or_record.techniqueWrap.db.techniques, var:t)

        add_field(descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.materialsTech.termMaterialsTech.$append.type, "technique")

        # Add each technique term from TMS to LIDO termMaterialsTech as LIDO term (type:preferred) along with the termID from TMS as LIDO conceptID (type:preferred)

        lido_term(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
            t.technique,
            -conceptid: t.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(t.subject, t.technique_aat)
        downcase(t.technique_aat)
        lookup_in_store(t.technique_aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO termMaterialsTech as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(t.technique_aat.aatterm, '.*\S.*')

            if all_match(t.technique_aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    t.technique_aat.aatterm,
                    -conceptid: t.technique_aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.materialsTech.termMaterialsTech.$last,
                    t.technique_aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

# LIDO displayMaterialsTech [eventType/term="production"]

    # Add medium from TMS as LIDO displayMaterialsTech

    if all_match(or_record.eventMaterialsTech.display, '.*\S.*')

        lido_basevalue(
            descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$append.displayMaterialsTech,
            or_record.eventMaterialsTech.display,
            -lang: nl
        )

    end

    do list(path:or_record.translations.db.translations, var:t)

        if all_match(t.textTypeID, '127')

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.displayMaterialsTech,
                t.textEntry,
                -lang: en
            )

        end

        if all_match(t.textTypeID, '128')

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.displayMaterialsTech,
                t.textEntry,
                -lang: fr
            )

        end

        if all_match(t.textTypeID, '139')

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.displayMaterialsTech,
                t.textEntry,
                -lang: de
            )

        end

        if all_match(t.textTypeID, '140')

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.displayMaterialsTech,
                t.textEntry,
                -lang: es
            )

        end

        if all_match(t.textTypeID, '141')

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.displayMaterialsTech,
                t.textEntry,
                -lang: it
            )

        end

        if all_match(t.textTypeID, '142')

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.displayMaterialsTech,
                t.textEntry,
                -lang: ru
            )

        end

        if all_match(t.textTypeID, '143')

            lido_basevalue(
                descriptiveMetadata.eventWrap.eventSet.$last.event.eventMaterialsTech.$last.displayMaterialsTech,
                t.textEntry,
                -lang: zh
            )

        end

    end


## LIDO objectRelationWrap

# LIDO subjectConcept

    # Content motif general

    # We'll have multiple terms for the type "content-motif-general": the corresponding value from the AAT vocabulary (type:alternate) and the value from TMS (type:preferred)

    # Loop over the different subject terms from TMS

    do list(path:or_record.subjectWrap.db.subjects, var:s)

        # Add type of LIDO subject

        add_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.type, "content-motif-general")

        # Add each subject term from TMS to LIDO subjectConcept as LIDO term (type:preferred) along with the termID from TMS as LIDO conceptID (type:preferred)

        lido_term(
            descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$append,
            s.subject,
            -conceptid: s.TermID,
            -type: local,
            -source: TMS,
            -pref: preferred,
            -lang: nl
        )

        copy_field(s.subject, s.content_motif_general)

        downcase(s.content_motif_general)

        lido_term(
            descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
            s.content_motif_general,
            -pref: alternate,
            -lang: nl
        )

        # Add the translation for the subject term from the translations vocabulary, this is not (yet) retrievable via TMS

        lookup_in_store(s.content_motif_general, DBI, data_source: "dbi:SQLite:/tmp/import.Translations.sqlite")

        if all_match(s.content_motif_general._id, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                s.content_motif_general.translation,
                -pref: alternate,
                -lang: en
            )

        end

        remove_field(s.content_motif_general)

        # Retrieve the corresponding term and URI from the AAT vocabulary, these are not (yet) retrievable via TMS

        copy_field(s.subject, s.aat)
        downcase(s.aat)
        lookup_in_store(s.aat, DBI, data_source: "dbi:SQLite:/tmp/import.AAT_UTF8.sqlite")

        # Add the corresponding term from the AAT vocabulary (if present) to LIDO classification as LIDO term (type:alternate) along with the URI from the AAT vocabulary (if present) as LIDO conceptID (type:alternate)

        if all_match(s.aat.aatterm, '.*\S.*')

            if all_match(s.aat.aaturi, '.*\S.*')

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                    s.aat.aatterm,
                    -conceptid: s.aat.aaturi,
                    -type: purl,
                    -source: AAT,
                    -pref: alternate,
                    -lang: nl
                )

            else

                lido_term(
                    descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                    s.aat.aatterm,
                    -pref: alternate,
                    -lang: nl
                )

            end

        end

    end

    # Iconclass

    # Loop over the different iconclass concepts from TMS

    do list(path:or_record.iconclass.db.iconclass, var:ic)

        # Remove unnecessary whitespaces

        trim(ic)

        paste(or_record.iconclassId, ic.TermSource, ic.SourceTermID, join_char:'')

        # Add each iconclass concept from TMS to LIDO subjectConcept as LIDO term along with the iconclass ID from TMS as LIDO conceptID

        lido_term(
            descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$append.subject.subjectConcept.$append,
            ic.term,
            -conceptid: or_record.iconclassId,
            -type: purl,
            -source: Iconclass,
            -pref: preferred,
            -lang: nl
        )

        set_field(descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.type, 'content-motif-specific')

        # Prevent reusing the same values in the next iteration

        remove_field(or_record.iconclassId)

        # English term

        copy_field(ic.SourceTermID, ic.english_term)

        lookup_in_store(ic.english_term, DBI, data_source: "dbi:SQLite:/tmp/import.iconclass_en.sqlite")

        unless all_match(ic.english_term.t, '.*\S.*')

            if all_match(ic.english_term, '^\d(?:\d(?:([A-Z])(?:\1)?\d*)?)?\([^\+][^\)]*\)\d*(?:\(\+\d+\))?.*')

                replace_all(ic.english_term, '^(\d(?:\d(?:([A-Z])(?:\2)?\d*)?)?\()[^\+][^\)]*(\)\d*(?:\(\+\d+\))?.*)', '$1...$3')

                lookup_in_store(ic.english_term, DBI, data_source: "dbi:SQLite:/tmp/import.iconclass_en.sqlite")

                if all_match(ic.english_term.t, '.*\(with [^\(]*[A-Z][A-Z]+[^\(]*\).*')

                    replace_all('ic.SourceTermID', '^\d(?:\d(?:([A-Z])(?:\1)?\d*)?)?\(([^\+][^\)]*)\)\d*(?:\(\+\d+\))?.*', '$2')
                    paste(ic.english_term.t, 'ic.SourceTermID', ic.english_term.t, join_char:'##KEYWORD##')
                    replace_all(ic.english_term.t, '(.*)##KEYWORD##(.*)\(with [^\(]*[A-Z][A-Z]+[^\(]*\)(.*)', '$1##KEYWORD##$2\($1\)$3')
                    replace_all(ic.english_term.t, '(.*)##KEYWORD##(.*)\(with [^\(]*[A-Z][A-Z]+[^\(]*\)(.*)', '$1##KEYWORD##$2\($1\)$3')
                    replace_all(ic.english_term.t, '.*##KEYWORD##(.*)', '$1')

                end

            end

        end

        if all_match(ic.english_term.t, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectRelationWrap.subjectWrap.subjectSet.$last.subject.subjectConcept.$last,
                ic.english_term.t,
                -pref: preferred,
                -lang: en
            )

        end

    end

# LIDO relatedWorksWrap

    # Loop over the different relations from TMS

    do list(path:or_record.relationWrap.db.relations, var:r)

        # Add a new, empty LIDO relationWorkSet field along with page number of related object from TMS (if present) as LIDO sortorder

        add_field(descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$append)

        if all_match(r.descriptionNumbering, 'paginanummer')

            if all_match(r.numbering, '[0-9]+')

                copy_field(r.numbering, descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.sortorder)

            end

        end

        # Add object number of related object from TMS as LIDO objectID

        lido_baseid(
            descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWork.object.objectID,
            r.relatedObjectNumber,
            -type: local,
            -source: TMS
        )

        # Reconstruate datahub record ID for related object (if exists)

        copy_field(r.relatedObjectNumber, r.relatedOaiPid)
        lookup_in_store(r.relatedOaiPid, DBI, data_source: 'dbi:SQLite:/tmp/tms_import.datapids.sqlite')
        parse_text(r.relatedOaiPid.dataPid, '.*://([A-Za-z0-9\-\.]+)/collection/work/data/(.*)')
        join_field(r.relatedOaiPid.dataPid, ':')
        prepend(r.relatedOaiPid.dataPid, 'oai:datahub.vlaamsekunstcollectie.be:')

        # Add the reconstruated datahub record ID as LIDO objectID

        if all_match(r.relatedOaiPid.dataPid, '.*\S.*')

            lido_baseid(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWork.object.objectID,
                r.relatedOaiPid.dataPid,
                -type: oai
            )

        end

        # Determine the English relationship terms and corresponding URI conform Dublin Core (if present)

        if all_match(r.relationshipID1, '.*\S.*')

            copy_field(r.relationshipID1, r.relationshipID)

            if all_match(r.relationshipID1, '0')
                set_field(r.relationshipEn, 'Has Part')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/hasPart')
            elsif all_match(r.relationshipID1, '3')
                set_field(r.relationshipEn, 'References')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/references')
            elsif all_match(r.relationshipID1, '6')
                set_field(r.relationshipEn, 'Back')
            elsif all_match(r.relationshipID1, '8')
                set_field(r.relationshipEn, 'Is Part Of')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/isPartOf')
            else
                set_field(r.relationshipEn, 'Relation')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/relation')
            end

        else

            copy_field(r.relationshipID2, r.relationshipID)

            if all_match(r.relationshipID2, '0')
                set_field(r.relationshipEn, 'Is Part Of')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/isPartOf')
            elsif all_match(r.relationshipID2, '3')
                set_field(r.relationshipEn, 'Is Referenced By')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/isReferencedBy')
            elsif all_match(r.relationshipID2, '6')
                set_field(r.relationshipEn, 'Front')
            elsif all_match(r.relationshipID2, '8')
                set_field(r.relationshipEn, 'Has Part')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/hasPart')
            else
                set_field(r.relationshipEn, 'Relation')
                set_field(r.relationshipURI, 'http://purl.org/dc/terms/relation')
            end

        end

        # Add relationship term from TMS to LIDO relatedWorkRelType as LIDO term along with the relationshipID from TMS as LIDO conceptID

        lido_term(
            descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWorkRelType,
            r.relationship,
            -conceptid: r.relationshipID,
            -source: TMS,
            -type: local
        )

        # Add English relationship term to LIDO relatedWorkRelType as LIDO term along with the URI from Dublin Core (if present) as LIDO conceptID

        if all_match(r.relationshipURI, '.*\S.*')

            lido_term(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWorkRelType,
                r.relationshipEn,
                -conceptid: r.relationshipURI,
                -type: URI,
                -pref: preferred,
                -lang: en
            )

        else

            lido_term(
                descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWorkRelType,
                r.relationshipEn,
                -pref: preferred,
                -lang: en
            )

        end

    end

    # Add each library link from TMS (if present) to LIDO relatedWorkSet as LIDO objectWebResource

    if all_match('or_record.linkLibrary', '.*\S.*')

        # Add a new, empty LIDO relationWorkSet field

        add_field(descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$append)

        # Create library link

        prepend(or_record.linkLibrary, 'https://anet.be/record/kmska/opackmska/')

        # Add the created library link to last created LIDO relatedWorkSet

        lido_basevalue(
            descriptiveMetadata.objectRelationWrap.relatedWorksWrap.relatedWorkSet.$last.relatedWork.object.objectWebResource,
            or_record.linkLibrary,
            -label: link-library
        )

    end



### LIDO administrativeMetadata

# LIDO rightsWorkWrap

    # Loop over the different constituents from TMS

    do list(path:or_record.constituentWrap.db.constituents, var:c)

        # Copy the copyright notice for each constituent from TMS

        copy_field(c.copyright, or_record.copyrights.$append)

    end

    # Loop over the created array with copyright notices

    do list(path:or_record.copyrights, var: c)

        # Remove unnecessary whitespaces

        trim(c)

        # If one of the copyright notices contains "SABAM", use this copyright notice

        if all_match(c, '.*SABAM.*')

            copy_field(c, or_record.copyright)

        else

            unless exists(or_record.copyright)

                copy_field(c, or_record.copyright)

            end

        end

    end

    # If the copyright notice is "CC0", add this to LIDO rightsType as LIDO term along with the URI from creativecommons.org as LIDO conceptID

    if all_match(or_record.copyright, 'CC0')

        set_field(or_record.copyrightUrl, 'https://creativecommons.org/publicdomain/zero/1.0/')

        lido_term(
            administrativeMetadata.rightsWorkWrap.rightsWorkSet.rightsType,
            or_record.copyright,
            -conceptid: or_record.copyrightUrl,
            -source: 'Creative Commons',
            -type: 'purl'
        )

    end

    # Add the copyright notice to LIDO creditLine

    if all_match(or_record.copyright, '.*\S.*')

        lido_basevalue(
            administrativeMetadata.rightsWorkWrap.rightsWorkSet.creditLine,
            or_record.copyright
        )

    end

# LIDO recordID

    # Add datapid from TMS as LIDO recordID (type:global)

    lido_baseid(
        administrativeMetadata.recordWrap.recordID,
        or_record.object_number.pid.dataPid,
        -type: global
    )

    # Add object number from TMS as LIDO recordID (type:local)

    lido_baseid(
        administrativeMetadata.recordWrap.recordID,
        or_record.object_number.tms,
        -type: local
    )

# LIDO recordType

    # Create AATRecordTypeTerm and AATRecordTypeID

    add_field('or_record.AATRecordTypeTerm', 'Item')
    add_field('or_record.AATRecordTypeID', 'http://vocab.getty.edu/aat/300133025')

    # Add the created AATRecordTypeTerm to LIDO recordType as LIDO term along with the AATRecordTypeID as LIDO conceptID

    lido_term(
        administrativeMetadata.recordWrap.recordType,
        or_record.AATRecordTypeTerm,
        -conceptid: or_record.AATRecordTypeID,
        -type: local,
        -source: AAT
    )

# LIDO recordSource

    # Add department ID from TMS to LIDO recordSource as LIDO legalBodyID

    lido_baseid(
        administrativeMetadata.recordWrap.recordSource.legalBodyID,
        or_record.department.db.DepartmentID,
        -type: local,
        -source: TMS
    )

    # Add department from TMS to LIDO recordSource as LIDO legalBodyName

    unless all_match(or_record.legalBodyName, '.*\S.*')
        add_field(or_record.legalBodyName, 'Koninklijk Museum voor Schone Kunsten Antwerpen')
    end

    lido_basenameset(
        administrativeMetadata.recordWrap.recordSource.legalBodyName,
        or_record.department.db.department
    )

    # Create legalBodyWeblink

    add_field(or_record.legalBodyWeblink, 'http://kmska.be')

    # Add the created legalBodyWeblink to LIDO recordSource as LIDO legalBodyWeblink

    lido_basevalue(
        administrativeMetadata.recordWrap.recordSource.legalBodyWeblink,
        or_record.legalBodyWeblink
    )


## LIDO resourceWrap

# LIDO resourceID & linkResource

    # Add IIIF manifest from the ImageHub to LIDO resourceSet as LIDO resourceID

    if all_match(or_record.iiif_manifest.manifest, '.*\S.*')

        copy_field(or_record.iiif_manifest.manifest, administrativeMetadata.resourceWrap.resourceSet.$append.resourceID._)
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceID.type, "purl")
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceID.source, "Imagehub")
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceType.term.$append._, "IIIF Manifest")
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceType.term.$last.pref, "preferred")

    end

    # Add IIIF thumbnail from the ImageHub to LIDO resourceSet as LIDO resourceID

    if all_match(or_record.iiif_manifest.thumbnail, '.*\S.*')

        copy_field(or_record.iiif_manifest.thumbnail, administrativeMetadata.resourceWrap.resourceSet.$append.resourceID._)
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceID.type, "purl")
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceID.source, "Imagehub")
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceType.term.$append._, "thumbnail")
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceType.term.$last.pref, "preferred")

    end

    # Add file checksum from DAM to LIDO resourceSet as LIDO resourceDescription

    if all_match(or_record.iiif_manifest.checksum, '.*\S.*')

        copy_field(or_record.iiif_manifest.checksum, administrativeMetadata.resourceWrap.resourceSet.$last.resourceDescription._)
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceDescription.type, "file-checksum")

    end

    # Add representationpid from TMS (if present) to LIDO resourceSet as LIDO resourceID and as LIDO linkResource

    if all_match(or_record.object_number.pid.representationPid, '.*\S.*')

        copy_field(or_record.object_number.pid.representationPid, administrativeMetadata.resourceWrap.resourceSet.$append.resourceID._)
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceID.type, "purl")
        add_field(administrativeMetadata.resourceWrap.resourceSet.$last.resourceID.label, "representationPID")

        copy_field(or_record.object_number.pid.representationPid, administrativeMetadata.resourceWrap.resourceSet.$last.resourceRepresentation.linkResource._)

    end



### Add lang attributes to descriptiveMetadata and administrativeMetadata

    add_field(descriptiveMetadata.lang, 'nl')
    add_field(administrativeMetadata.lang, 'nl')



### Add empty values for required LIDO elements/attributes if not already exist

    unless exists(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType)
        add_field(descriptiveMetadata.objectClassificationWrap.objectWorkTypeWrap.objectWorkType.term._, "")
    end



### Remove the 'or_record' structure

    remove_field(or_record)
